{"ast":null,"code":"import _toConsumableArray from \"/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { Delaunay } from \"d3-delaunay\";\nimport { scaleLinear } from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\nexport default function () {\n  var _marked = /*#__PURE__*/_regeneratorRuntime.mark(tricontours),\n      _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(isobands);\n\n  // accessors\n  var x = function x(d) {\n    return d[0];\n  },\n      y = function y(d) {\n    return d[1];\n  },\n      value = function value(d) {\n    return isFinite(+d[2]) ? +d[2] : 0;\n  },\n      triangulate = Delaunay.from,\n      pointInterpolate = function pointInterpolate(i, j, a) {\n    var _triangulation = triangulation,\n        points = _triangulation.points;\n    var A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n    return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n  },\n      ringsort = planarRingsort;\n\n  var thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear().domain(extent(values)).nice().ticks(thresholds);\n    }\n  }\n\n  function tricontours(points) {\n    var _iterator, _step, threshold, polygon;\n\n    return _regeneratorRuntime.wrap(function tricontours$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            init(points);\n            _iterator = _createForOfIteratorHelper(thresholds);\n            _context.prev = 2;\n\n            _iterator.s();\n\n          case 4:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 11;\n              break;\n            }\n\n            threshold = _step.value;\n            polygon = tricontour(triangulation, values, threshold);\n            _context.next = 9;\n            return {\n              type: \"MultiPolygon\",\n              coordinates: polygon,\n              value: threshold\n            };\n\n          case 9:\n            _context.next = 4;\n            break;\n\n          case 11:\n            _context.next = 16;\n            break;\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](2);\n\n            _iterator.e(_context.t0);\n\n          case 16:\n            _context.prev = 16;\n\n            _iterator.f();\n\n            return _context.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _marked, null, [[2, 13, 16, 19]]);\n  }\n\n  function contour(points, threshold) {\n    init(points);\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function isobands(points) {\n    var p0, p1, th0, _iterator2, _step2, th;\n\n    return _regeneratorRuntime.wrap(function isobands$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            init(points);\n            _iterator2 = _createForOfIteratorHelper(thresholds);\n            _context2.prev = 2;\n\n            _iterator2.s();\n\n          case 4:\n            if ((_step2 = _iterator2.n()).done) {\n              _context2.next = 14;\n              break;\n            }\n\n            th = _step2.value;\n            if (p1) p0 = p1;\n            p1 = merge(tricontour(triangulation, values, th));\n\n            if (!p0) {\n              _context2.next = 11;\n              break;\n            }\n\n            _context2.next = 11;\n            return {\n              type: \"MultiPolygon\",\n              coordinates: ringsort(p0.concat(p1.map(function (ring) {\n                return ring.slice().reverse();\n              }))),\n              value: th0,\n              valueMax: th\n            };\n\n          case 11:\n            th0 = th;\n\n          case 12:\n            _context2.next = 4;\n            break;\n\n          case 14:\n            _context2.next = 19;\n            break;\n\n          case 16:\n            _context2.prev = 16;\n            _context2.t0 = _context2[\"catch\"](2);\n\n            _iterator2.e(_context2.t0);\n\n          case 19:\n            _context2.prev = 19;\n\n            _iterator2.f();\n\n            return _context2.finish(19);\n\n          case 22:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _marked2, null, [[2, 16, 19, 22]]);\n  }\n\n  var contours = function contours(data) {\n    return _toConsumableArray(tricontours(data));\n  }; // API\n\n\n  contours.x = function (_) {\n    return _ ? (x = _, contours) : x;\n  };\n\n  contours.y = function (_) {\n    return _ ? (y = _, contours) : y;\n  };\n\n  contours.value = function (_) {\n    return _ ? (value = _, contours) : value;\n  };\n\n  contours.thresholds = function (_) {\n    return _ ? (thresholds = _, contours) : thresholds;\n  };\n\n  contours.triangulate = function (_) {\n    return _ ? (triangulate = _, contours) : triangulate;\n  };\n\n  contours.pointInterpolate = function (_) {\n    return _ ? (pointInterpolate = _, contours) : pointInterpolate;\n  };\n\n  contours.ringsort = function (_) {\n    return _ ? (ringsort = _, contours) : ringsort;\n  };\n\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands; // expose the internals (useful for debugging, not part of the API)\n\n  contours._values = function () {\n    return values;\n  };\n\n  contours._thresholds = function () {\n    return thresholds;\n  };\n\n  contours._triangulation = function () {\n    return triangulation;\n  };\n\n  return contours; // navigate a triangle\n\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values) {\n    var v0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    // sanity check\n    var _iterator3 = _createForOfIteratorHelper(values),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var d = _step3.value;\n        if (!isFinite(d)) throw [\"Invalid value\", d];\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var halfedges = triangulation.halfedges,\n        hull = triangulation.hull,\n        inedges = triangulation.inedges,\n        triangles = triangulation.triangles,\n        n = values.length;\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n\n    function alpha(i, j) {\n      var u = values[i],\n          v = values[j];\n\n      if ((u - v0) * (v - v0) <= 0 && u - v) {\n        return (v0 - u) / Math.abs(u - v);\n      }\n    } // create the path from the first exit; cancel visited halfedges\n\n\n    var rings = [],\n        visited = new Uint8Array(halfedges.length).fill(0);\n    var path, i, j, k, a;\n\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        var _ref = [triangles[i], triangles[j = next(i)]],\n            ti = _ref[0],\n            tj = _ref[1]; // is our tour done?\n\n        if (path.length && ti === path[0].ti && tj === path[0].tj || path.length > 2 * n) break;\n        visited[i] = 1;\n        path.push({\n          ti: ti,\n          tj: tj,\n          a: a\n        }); // jump into the adjacent triangle\n\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          } // debugger;\n\n        } // or follow the hull\n        else {\n            var h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n\n            while (values[hull[h]] < v0) {\n              // debugger;\n              h = (h + 1) % hull.length;\n            }\n\n            while (values[hull[h]] >= v0) {\n              path.push({\n                ti: hull[h],\n                tj: hull[h],\n                a: 0\n              });\n              h = (h + 1) % hull.length;\n            } // take that entry\n\n\n            j = inedges[hull[h]];\n            path.push({\n              ti: hull[h],\n              tj: triangles[j],\n              a: alpha(hull[h], triangles[j])\n            });\n            if (edgealpha(i = next(j)) > 0) continue;\n            if (edgealpha(i = prev(j)) > 0) continue;\n          }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(function (_ref2) {\n          var ti = _ref2.ti,\n              tj = _ref2.tj,\n              a = _ref2.a;\n          return pointInterpolate(ti, tj, a);\n        }));\n      }\n    } // special case all values on the hull are >=v0, add the hull\n\n\n    if (hull.every(function (d) {\n      return values[d] >= v0;\n    })) {\n      rings.unshift(Array.from(hull).concat([hull[0]]).map(function (i) {\n        return pointInterpolate(i, i, 0);\n      }));\n    }\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}","map":{"version":3,"sources":["/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/d3-tricontour/src/tricontour.js"],"names":["Delaunay","scaleLinear","extent","merge","planarRingsort","tricontours","isobands","x","d","y","value","isFinite","triangulate","from","pointInterpolate","i","j","a","triangulation","points","A","B","ringsort","thresholds","values","init","Array","domain","nice","ticks","threshold","polygon","tricontour","type","coordinates","contour","th","p1","p0","concat","map","ring","slice","reverse","th0","valueMax","contours","data","_","_values","_thresholds","_triangulation","next","prev","v0","halfedges","hull","inedges","triangles","n","length","edgealpha","alpha","u","v","Math","abs","rings","visited","Uint8Array","fill","path","k","ti","tj","push","h","indexOf","every","unshift"],"mappings":";;;AAAA,SAAQA,QAAR,QAAuB,aAAvB;AACA,SAAQC,WAAR,QAA0B,UAA1B;AACA,OAAOC,MAAP,MAAmB,aAAnB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,cAAP,MAA2B,eAA3B;AAEA,eAAe,YAAW;AAAA,sDA2BdC,WA3Bc;AAAA,uDAkDdC,QAlDc;;AACxB;AACA,MAAIC,CAAC,GAAG,WAAAC,CAAC;AAAA,WAAIA,CAAC,CAAC,CAAD,CAAL;AAAA,GAAT;AAAA,MACEC,CAAC,GAAG,WAAAD,CAAC;AAAA,WAAIA,CAAC,CAAC,CAAD,CAAL;AAAA,GADP;AAAA,MAEEE,KAAK,GAAG,eAAAF,CAAC;AAAA,WAAKG,QAAQ,CAAC,CAACH,CAAC,CAAC,CAAD,CAAH,CAAR,GAAkB,CAACA,CAAC,CAAC,CAAD,CAApB,GAA0B,CAA/B;AAAA,GAFX;AAAA,MAGEI,WAAW,GAAGZ,QAAQ,CAACa,IAHzB;AAAA,MAIEC,gBAAgB,GAAG,0BAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,EAAa;AAAA,yBACXC,aADW;AAAA,QACtBC,MADsB,kBACtBA,MADsB;AAE9B,QAAMC,CAAC,GAAG,CAACD,MAAM,CAAC,IAAIJ,CAAL,CAAP,EAAgBI,MAAM,CAAC,IAAIJ,CAAJ,GAAQ,CAAT,CAAtB,CAAV;AAAA,QACEM,CAAC,GAAG,CAACF,MAAM,CAAC,IAAIH,CAAL,CAAP,EAAgBG,MAAM,CAAC,IAAIH,CAAJ,GAAQ,CAAT,CAAtB,CADN;AAEA,WAAO,CAACC,CAAC,GAAGI,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,IAAIJ,CAAL,IAAUG,CAAC,CAAC,CAAD,CAAvB,EAA4BH,CAAC,GAAGI,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,IAAIJ,CAAL,IAAUG,CAAC,CAAC,CAAD,CAAlD,CAAP;AACD,GATH;AAAA,MAUEE,QAAQ,GAAGlB,cAVb;;AAYA,MAAImB,UAAJ,EAAgBC,MAAhB,EAAwBN,aAAxB;;AAEA,WAASO,IAAT,CAAcN,MAAd,EAAsB;AACpBD,IAAAA,aAAa,GAAGN,WAAW,CAACO,MAAD,EAASZ,CAAT,EAAYE,CAAZ,CAA3B;AACAe,IAAAA,MAAM,GAAGE,KAAK,CAACb,IAAN,CAAWM,MAAX,EAAmBT,KAAnB,CAAT;;AACA,QAAI,OAAOa,UAAP,KAAsB,QAA1B,EAAoC;AAClCA,MAAAA,UAAU,GAAGtB,WAAW,GACrB0B,MADU,CACHzB,MAAM,CAACsB,MAAD,CADH,EAEVI,IAFU,GAGVC,KAHU,CAGJN,UAHI,CAAb;AAID;AACF;;AAED,WAAUlB,WAAV,CAAsBc,MAAtB;AAAA;;AAAA;AAAA;AAAA;AAAA;AACEM,YAAAA,IAAI,CAACN,MAAD,CAAJ;AADF,mDAG0BI,UAH1B;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGaO,YAAAA,SAHb;AAIUC,YAAAA,OAJV,GAIoBC,UAAU,CAACd,aAAD,EAAgBM,MAAhB,EAAwBM,SAAxB,CAJ9B;AAAA;AAKI,mBAAM;AACJG,cAAAA,IAAI,EAAE,cADF;AAEJC,cAAAA,WAAW,EAAEH,OAFT;AAGJrB,cAAAA,KAAK,EAAEoB;AAHH,aAAN;;AALJ;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA,WAASK,OAAT,CAAiBhB,MAAjB,EAAyBW,SAAzB,EAAoC;AAClCL,IAAAA,IAAI,CAACN,MAAD,CAAJ;AAEA,WAAO;AACLc,MAAAA,IAAI,EAAE,cADD;AAELC,MAAAA,WAAW,EAAEF,UAAU,CAACd,aAAD,EAAgBM,MAAhB,EAAwBM,SAAxB,CAFlB;AAGLpB,MAAAA,KAAK,EAAEoB;AAHF,KAAP;AAKD;;AAED,WAAUxB,QAAV,CAAmBa,MAAnB;AAAA;;AAAA;AAAA;AAAA;AAAA;AACEM,YAAAA,IAAI,CAACN,MAAD,CAAJ;AADF,oDAImBI,UAJnB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIaa,YAAAA,EAJb;AAKI,gBAAIC,EAAJ,EAAQC,EAAE,GAAGD,EAAL;AACRA,YAAAA,EAAE,GAAGlC,KAAK,CAAC6B,UAAU,CAACd,aAAD,EAAgBM,MAAhB,EAAwBY,EAAxB,CAAX,CAAV;;AANJ,iBAOQE,EAPR;AAAA;AAAA;AAAA;;AAAA;AAQM,mBAAM;AACJL,cAAAA,IAAI,EAAE,cADF;AAEJC,cAAAA,WAAW,EAAEZ,QAAQ,CACnBgB,EAAE,CAACC,MAAH,CAAUF,EAAE,CAACG,GAAH,CAAO,UAAAC,IAAI;AAAA,uBAAIA,IAAI,CAACC,KAAL,GAAaC,OAAb,EAAJ;AAAA,eAAX,CAAV,CADmB,CAFjB;AAKJjC,cAAAA,KAAK,EAAEkC,GALH;AAMJC,cAAAA,QAAQ,EAAET;AANN,aAAN;;AARN;AAiBIQ,YAAAA,GAAG,GAAGR,EAAN;;AAjBJ;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA,MAAMU,QAAQ,GAAG,SAAXA,QAAW,CAASC,IAAT,EAAe;AAC9B,8BAAW1C,WAAW,CAAC0C,IAAD,CAAtB;AACD,GAFD,CAvEwB,CA2ExB;;;AACAD,EAAAA,QAAQ,CAACvC,CAAT,GAAa,UAAAyC,CAAC;AAAA,WAAKA,CAAC,IAAKzC,CAAC,GAAGyC,CAAL,EAASF,QAAb,IAAyBvC,CAA/B;AAAA,GAAd;;AACAuC,EAAAA,QAAQ,CAACrC,CAAT,GAAa,UAAAuC,CAAC;AAAA,WAAKA,CAAC,IAAKvC,CAAC,GAAGuC,CAAL,EAASF,QAAb,IAAyBrC,CAA/B;AAAA,GAAd;;AACAqC,EAAAA,QAAQ,CAACpC,KAAT,GAAiB,UAAAsC,CAAC;AAAA,WAAKA,CAAC,IAAKtC,KAAK,GAAGsC,CAAT,EAAaF,QAAjB,IAA6BpC,KAAnC;AAAA,GAAlB;;AACAoC,EAAAA,QAAQ,CAACvB,UAAT,GAAsB,UAAAyB,CAAC;AAAA,WAAKA,CAAC,IAAKzB,UAAU,GAAGyB,CAAd,EAAkBF,QAAtB,IAAkCvB,UAAxC;AAAA,GAAvB;;AACAuB,EAAAA,QAAQ,CAAClC,WAAT,GAAuB,UAAAoC,CAAC;AAAA,WAAKA,CAAC,IAAKpC,WAAW,GAAGoC,CAAf,EAAmBF,QAAvB,IAAmClC,WAAzC;AAAA,GAAxB;;AACAkC,EAAAA,QAAQ,CAAChC,gBAAT,GAA4B,UAAAkC,CAAC;AAAA,WAC3BA,CAAC,IAAKlC,gBAAgB,GAAGkC,CAApB,EAAwBF,QAA5B,IAAwChC,gBADd;AAAA,GAA7B;;AAEAgC,EAAAA,QAAQ,CAACxB,QAAT,GAAoB,UAAA0B,CAAC;AAAA,WACnBA,CAAC,IAAK1B,QAAQ,GAAG0B,CAAZ,EAAgBF,QAApB,IAAgCxB,QADd;AAAA,GAArB;;AAEAwB,EAAAA,QAAQ,CAACA,QAAT,GAAoBzC,WAApB;AACAyC,EAAAA,QAAQ,CAACX,OAAT,GAAmBA,OAAnB;AACAW,EAAAA,QAAQ,CAACxC,QAAT,GAAoBA,QAApB,CAvFwB,CAyFxB;;AACAwC,EAAAA,QAAQ,CAACG,OAAT,GAAmB;AAAA,WAAMzB,MAAN;AAAA,GAAnB;;AACAsB,EAAAA,QAAQ,CAACI,WAAT,GAAuB;AAAA,WAAM3B,UAAN;AAAA,GAAvB;;AACAuB,EAAAA,QAAQ,CAACK,cAAT,GAA0B;AAAA,WAAMjC,aAAN;AAAA,GAA1B;;AAEA,SAAO4B,QAAP,CA9FwB,CAgGxB;;AACA,WAASM,IAAT,CAAcrC,CAAd,EAAiB;AACf,WAAOA,CAAC,GAAG,CAAJ,KAAU,CAAV,GAAcA,CAAC,GAAG,CAAlB,GAAsBA,CAAC,GAAG,CAAjC;AACD;;AACD,WAASsC,IAAT,CAActC,CAAd,EAAiB;AACf,WAAOA,CAAC,GAAG,CAAJ,KAAU,CAAV,GAAcA,CAAC,GAAG,CAAlB,GAAsBA,CAAC,GAAG,CAAjC;AACD;;AAED,WAASiB,UAAT,CAAoBd,aAApB,EAAmCM,MAAnC,EAAmD;AAAA,QAAR8B,EAAQ,uEAAH,CAAG;;AACjD;AADiD,gDAEjC9B,MAFiC;AAAA;;AAAA;AAEjD;AAAA,YAAWhB,CAAX;AAAwB,YAAI,CAACG,QAAQ,CAACH,CAAD,CAAb,EAAkB,MAAM,CAAC,eAAD,EAAkBA,CAAlB,CAAN;AAA1C;AAFiD;AAAA;AAAA;AAAA;AAAA;;AAAA,QAIzC+C,SAJyC,GAIDrC,aAJC,CAIzCqC,SAJyC;AAAA,QAI9BC,IAJ8B,GAIDtC,aAJC,CAI9BsC,IAJ8B;AAAA,QAIxBC,OAJwB,GAIDvC,aAJC,CAIxBuC,OAJwB;AAAA,QAIfC,SAJe,GAIDxC,aAJC,CAIfwC,SAJe;AAAA,QAK/CC,CAL+C,GAK3CnC,MAAM,CAACoC,MALoC;;AAOjD,aAASC,SAAT,CAAmB9C,CAAnB,EAAsB;AACpB,aAAO+C,KAAK,CAACJ,SAAS,CAAC3C,CAAD,CAAV,EAAe2C,SAAS,CAACN,IAAI,CAACrC,CAAD,CAAL,CAAxB,CAAZ;AACD;;AACD,aAAS+C,KAAT,CAAe/C,CAAf,EAAkBC,CAAlB,EAAqB;AACnB,UAAM+C,CAAC,GAAGvC,MAAM,CAACT,CAAD,CAAhB;AAAA,UACEiD,CAAC,GAAGxC,MAAM,CAACR,CAAD,CADZ;;AAEA,UAAI,CAAC+C,CAAC,GAAGT,EAAL,KAAYU,CAAC,GAAGV,EAAhB,KAAuB,CAAvB,IAA4BS,CAAC,GAAGC,CAApC,EAAuC;AACrC,eAAO,CAACV,EAAE,GAAGS,CAAN,IAAWE,IAAI,CAACC,GAAL,CAASH,CAAC,GAAGC,CAAb,CAAlB;AACD;AACF,KAhBgD,CAkBjD;;;AACA,QAAMG,KAAK,GAAG,EAAd;AAAA,QACEC,OAAO,GAAG,IAAIC,UAAJ,CAAed,SAAS,CAACK,MAAzB,EAAiCU,IAAjC,CAAsC,CAAtC,CADZ;AAEA,QAAIC,IAAJ,EAAUxD,CAAV,EAAaC,CAAb,EAAgBwD,CAAhB,EAAmBvD,CAAnB;;AACA,SAAKuD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGjB,SAAS,CAACK,MAA1B,EAAkCY,CAAC,EAAnC,EAAuC;AACrC,UAAIJ,OAAO,CAACI,CAAD,CAAX,EAAgB;AAEhBzD,MAAAA,CAAC,GAAGyD,CAAJ;AACAD,MAAAA,IAAI,GAAG,EAAP;;AAEA,aAAO,CAACtD,CAAC,GAAG4C,SAAS,CAAC9C,CAAD,CAAd,IAAqB,CAA5B,EAA+B;AAAA,mBACZ,CAAC2C,SAAS,CAAC3C,CAAD,CAAV,EAAe2C,SAAS,CAAE1C,CAAC,GAAGoC,IAAI,CAACrC,CAAD,CAAV,CAAxB,CADY;AAAA,YACtB0D,EADsB;AAAA,YAClBC,EADkB,YAG7B;;AACA,YACGH,IAAI,CAACX,MAAL,IAAgBa,EAAE,KAAKF,IAAI,CAAC,CAAD,CAAJ,CAAQE,EAAf,IAAqBC,EAAE,KAAKH,IAAI,CAAC,CAAD,CAAJ,CAAQG,EAArD,IACAH,IAAI,CAACX,MAAL,GAAc,IAAID,CAFpB,EAIE;AAEFS,QAAAA,OAAO,CAACrD,CAAD,CAAP,GAAa,CAAb;AACAwD,QAAAA,IAAI,CAACI,IAAL,CAAU;AAAEF,UAAAA,EAAE,EAAFA,EAAF;AAAMC,UAAAA,EAAE,EAAFA,EAAN;AAAUzD,UAAAA,CAAC,EAADA;AAAV,SAAV,EAX6B,CAa7B;;AACA,YAAI,CAACD,CAAC,GAAGuC,SAAS,CAACxC,CAAD,CAAd,IAAqB,CAAC,CAA1B,EAA6B;AAC3B,cAAI8C,SAAS,CAAE7C,CAAC,GAAGoC,IAAI,CAACpC,CAAD,CAAV,CAAT,GAA2B,CAA/B,EAAkC;AAChCD,YAAAA,CAAC,GAAGC,CAAJ;AACA;AACD;;AACD,cAAI6C,SAAS,CAAE7C,CAAC,GAAGoC,IAAI,CAACpC,CAAD,CAAV,CAAT,GAA2B,CAA/B,EAAkC;AAChCD,YAAAA,CAAC,GAAGC,CAAJ;AACA;AACD,WAR0B,CAS3B;;AACD,SAVD,CAYA;AAZA,aAaK;AACH,gBAAI4D,CAAC,GAAG,CAACpB,IAAI,CAACqB,OAAL,CAAanB,SAAS,CAAC3C,CAAD,CAAtB,IAA6B,CAA9B,IAAmCyC,IAAI,CAACI,MAAhD;;AAEA,mBAAOpC,MAAM,CAACgC,IAAI,CAACoB,CAAD,CAAL,CAAN,GAAkBtB,EAAzB,EAA6B;AAC3B;AACAsB,cAAAA,CAAC,GAAG,CAACA,CAAC,GAAG,CAAL,IAAUpB,IAAI,CAACI,MAAnB;AACD;;AAED,mBAAOpC,MAAM,CAACgC,IAAI,CAACoB,CAAD,CAAL,CAAN,IAAmBtB,EAA1B,EAA8B;AAC5BiB,cAAAA,IAAI,CAACI,IAAL,CAAU;AAAEF,gBAAAA,EAAE,EAAEjB,IAAI,CAACoB,CAAD,CAAV;AAAeF,gBAAAA,EAAE,EAAElB,IAAI,CAACoB,CAAD,CAAvB;AAA4B3D,gBAAAA,CAAC,EAAE;AAA/B,eAAV;AACA2D,cAAAA,CAAC,GAAG,CAACA,CAAC,GAAG,CAAL,IAAUpB,IAAI,CAACI,MAAnB;AACD,aAXE,CAaH;;;AACA5C,YAAAA,CAAC,GAAGyC,OAAO,CAACD,IAAI,CAACoB,CAAD,CAAL,CAAX;AACAL,YAAAA,IAAI,CAACI,IAAL,CAAU;AACRF,cAAAA,EAAE,EAAEjB,IAAI,CAACoB,CAAD,CADA;AAERF,cAAAA,EAAE,EAAEhB,SAAS,CAAC1C,CAAD,CAFL;AAGRC,cAAAA,CAAC,EAAE6C,KAAK,CAACN,IAAI,CAACoB,CAAD,CAAL,EAAUlB,SAAS,CAAC1C,CAAD,CAAnB;AAHA,aAAV;AAMA,gBAAI6C,SAAS,CAAE9C,CAAC,GAAGqC,IAAI,CAACpC,CAAD,CAAV,CAAT,GAA2B,CAA/B,EAAkC;AAClC,gBAAI6C,SAAS,CAAE9C,CAAC,GAAGsC,IAAI,CAACrC,CAAD,CAAV,CAAT,GAA2B,CAA/B,EAAkC;AACnC;AACF;;AAED,UAAIuD,IAAI,CAACX,MAAT,EAAiB;AACfW,QAAAA,IAAI,CAACI,IAAL,CAAUJ,IAAI,CAAC,CAAD,CAAd;AACAJ,QAAAA,KAAK,CAACQ,IAAN,CAAWJ,IAAI,CAAC/B,GAAL,CAAS;AAAA,cAAGiC,EAAH,SAAGA,EAAH;AAAA,cAAOC,EAAP,SAAOA,EAAP;AAAA,cAAWzD,CAAX,SAAWA,CAAX;AAAA,iBAAmBH,gBAAgB,CAAC2D,EAAD,EAAKC,EAAL,EAASzD,CAAT,CAAnC;AAAA,SAAT,CAAX;AACD;AACF,KArFgD,CAuFjD;;;AACA,QAAIuC,IAAI,CAACsB,KAAL,CAAW,UAAAtE,CAAC;AAAA,aAAIgB,MAAM,CAAChB,CAAD,CAAN,IAAa8C,EAAjB;AAAA,KAAZ,CAAJ,EAAsC;AACpCa,MAAAA,KAAK,CAACY,OAAN,CACErD,KAAK,CAACb,IAAN,CAAW2C,IAAX,EACGjB,MADH,CACU,CAACiB,IAAI,CAAC,CAAD,CAAL,CADV,EAEGhB,GAFH,CAEO,UAAAzB,CAAC;AAAA,eAAID,gBAAgB,CAACC,CAAD,EAAIA,CAAJ,EAAO,CAAP,CAApB;AAAA,OAFR,CADF;AAKD;;AAED,WAAOO,QAAQ,CAAC6C,KAAD,CAAf,CAhGiD,CAgGzB;AACzB;AACF","sourcesContent":["import {Delaunay} from \"d3-delaunay\";\nimport {scaleLinear} from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\n\nexport default function() {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => (isFinite(+d[2]) ? +d[2] : 0),\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const { points } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n\n  let thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear()\n        .domain(extent(values))\n        .nice()\n        .ticks(thresholds);\n    }\n  }\n\n  function* tricontours(points) {\n    init(points);\n\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n\n  function contour(points, threshold) {\n    init(points);\n\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function* isobands(points) {\n    init(points);\n\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(\n            p0.concat(p1.map(ring => ring.slice().reverse()))\n          ),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n\n  const contours = function(data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => (_ ? ((x = _), contours) : x);\n  contours.y = _ => (_ ? ((y = _), contours) : y);\n  contours.value = _ => (_ ? ((value = _), contours) : value);\n  contours.thresholds = _ => (_ ? ((thresholds = _), contours) : thresholds);\n  contours.triangulate = _ => (_ ? ((triangulate = _), contours) : triangulate);\n  contours.pointInterpolate = _ =>\n    _ ? ((pointInterpolate = _), contours) : pointInterpolate;\n  contours.ringsort = _ =>\n    _ ? ((ringsort = _), contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._thresholds = () => thresholds;\n  contours._triangulation = () => triangulation;\n\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values, v0 = 0) {\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n\n    const { halfedges, hull, inedges, triangles } = triangulation,\n      n = values.length;\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if ((u - v0) * (v - v0) <= 0 && u - v) {\n        return (v0 - u) / Math.abs(u - v);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[(j = next(i))]];\n\n        // is our tour done?\n        if (\n          (path.length && (ti === path[0].ti && tj === path[0].tj)) ||\n          path.length > 2 * n\n        )\n          break;\n\n        visited[i] = 1;\n        path.push({ ti, tj, a });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n\n          while (values[hull[h]] >= v0) {\n            path.push({ ti: hull[h], tj: hull[h], a: 0 });\n            h = (h + 1) % hull.length;\n          }\n\n          // take that entry\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n\n          if (edgealpha((i = next(j))) > 0) continue;\n          if (edgealpha((i = prev(j))) > 0) continue;\n        }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(({ ti, tj, a }) => pointInterpolate(ti, tj, a)));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(\n        Array.from(hull)\n          .concat([hull[0]])\n          .map(i => pointInterpolate(i, i, 0))\n      );\n    }\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}"]},"metadata":{},"sourceType":"module"}