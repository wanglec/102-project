{"ast":null,"code":"//\n// (c) 2019 Philippe Riviere\n//\n// https://github.com/Fil/\n//\n// This software is distributed under the terms of the MIT License\nimport { geoDelaunay } from \"./delaunay.js\";\nimport { geoInterpolate } from \"d3-geo\";\nimport { tricontour } from \"d3-tricontour\";\nexport function geoContour() {\n  let v;\n  const contour = tricontour().triangulate((data, x, y) => {\n    v = geoDelaunay(data.map(d => [x(d), y(d)]));\n    return v.delaunay;\n  }).pointInterpolate((i, j, a) => {\n    const {\n      points,\n      projection\n    } = v.delaunay;\n    const A = projection.invert([points[2 * i], points[2 * i + 1]]),\n          B = projection.invert([points[2 * j], points[2 * j + 1]]);\n    return geoInterpolate(A, B)(a);\n  }).ringsort(rings => {\n    // tricky thing: in isobands this function is called twice,\n    // we want to reverse the polygons’s winding order only in tricontour()\n    // not in isoband()\n    if (rings.length && !rings[0].reversed) {\n      rings.forEach(ring => ring.reverse());\n      rings[0].reversed = true;\n    }\n\n    return [rings];\n  });\n  return contour;\n}","map":{"version":3,"sources":["/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/d3-geo-voronoi/src/contour.js"],"names":["geoDelaunay","geoInterpolate","tricontour","geoContour","v","contour","triangulate","data","x","y","map","d","delaunay","pointInterpolate","i","j","a","points","projection","A","invert","B","ringsort","rings","length","reversed","forEach","ring","reverse"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,WAAR,QAA0B,eAA1B;AACA,SAAQC,cAAR,QAA6B,QAA7B;AACA,SAAQC,UAAR,QAAyB,eAAzB;AAEA,OAAO,SAASC,UAAT,GAAsB;AAC3B,MAAIC,CAAJ;AACA,QAAMC,OAAO,GAAGH,UAAU,GACvBI,WADa,CACD,CAACC,IAAD,EAAOC,CAAP,EAAUC,CAAV,KAAgB;AAC3BL,IAAAA,CAAC,GAAGJ,WAAW,CAACO,IAAI,CAACG,GAAL,CAASC,CAAC,IAAI,CAACH,CAAC,CAACG,CAAD,CAAF,EAAOF,CAAC,CAACE,CAAD,CAAR,CAAd,CAAD,CAAf;AACA,WAAOP,CAAC,CAACQ,QAAT;AACD,GAJa,EAKbC,gBALa,CAKI,CAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,KAAa;AAC7B,UAAM;AAAEC,MAAAA,MAAF;AAAUC,MAAAA;AAAV,QAAyBd,CAAC,CAACQ,QAAjC;AACA,UAAMO,CAAC,GAAGD,UAAU,CAACE,MAAX,CAAkB,CAACH,MAAM,CAAC,IAAIH,CAAL,CAAP,EAAgBG,MAAM,CAAC,IAAIH,CAAJ,GAAQ,CAAT,CAAtB,CAAlB,CAAV;AAAA,UACGO,CAAC,GAAGH,UAAU,CAACE,MAAX,CAAkB,CAACH,MAAM,CAAC,IAAIF,CAAL,CAAP,EAAgBE,MAAM,CAAC,IAAIF,CAAJ,GAAQ,CAAT,CAAtB,CAAlB,CADP;AAEA,WAAOd,cAAc,CAACkB,CAAD,EAAIE,CAAJ,CAAd,CAAqBL,CAArB,CAAP;AACD,GAVa,EAWbM,QAXa,CAWJC,KAAK,IAAI;AACjB;AACA;AACA;AACA,QAAIA,KAAK,CAACC,MAAN,IAAgB,CAACD,KAAK,CAAC,CAAD,CAAL,CAASE,QAA9B,EAAwC;AACtCF,MAAAA,KAAK,CAACG,OAAN,CAAcC,IAAI,IAAIA,IAAI,CAACC,OAAL,EAAtB;AACAL,MAAAA,KAAK,CAAC,CAAD,CAAL,CAASE,QAAT,GAAoB,IAApB;AACD;;AACD,WAAO,CAACF,KAAD,CAAP;AACD,GApBa,CAAhB;AAsBA,SAAOlB,OAAP;AACD","sourcesContent":["//\n// (c) 2019 Philippe Riviere\n//\n// https://github.com/Fil/\n//\n// This software is distributed under the terms of the MIT License\n\nimport {geoDelaunay} from \"./delaunay.js\";\nimport {geoInterpolate} from \"d3-geo\";\nimport {tricontour} from \"d3-tricontour\";\n\nexport function geoContour() {\n  let v;\n  const contour = tricontour()\n    .triangulate((data, x, y) => {\n      v = geoDelaunay(data.map(d => [x(d), y(d)]));\n      return v.delaunay;\n    })\n    .pointInterpolate((i, j, a) => {\n      const { points, projection } = v.delaunay;\n      const A = projection.invert([points[2 * i], points[2 * i + 1]]),\n         B = projection.invert([points[2 * j], points[2 * j + 1]]);\n      return geoInterpolate(A, B)(a);\n    })\n    .ringsort(rings => {\n      // tricky thing: in isobands this function is called twice,\n      // we want to reverse the polygons’s winding order only in tricontour()\n      // not in isoband()\n      if (rings.length && !rings[0].reversed) {\n        rings.forEach(ring => ring.reverse());\n        rings[0].reversed = true;\n      }\n      return [rings];\n    });\n\n  return contour;\n}\n"]},"metadata":{},"sourceType":"module"}