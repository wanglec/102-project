{"ast":null,"code":"import _classCallCheck from \"/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { BufferAttribute, BufferGeometry, Float32BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3 } from 'three';\n\nvar BufferGeometryUtils = /*#__PURE__*/function () {\n  function BufferGeometryUtils() {\n    _classCallCheck(this, BufferGeometryUtils);\n  }\n\n  _createClass(BufferGeometryUtils, null, [{\n    key: \"computeTangents\",\n    value: function computeTangents(geometry) {\n      geometry.computeTangents();\n      console.warn('THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.');\n    }\n    /**\n     * @param  {Array<BufferGeometry>} geometries\n     * @param  {Boolean} useGroups\n     * @return {BufferGeometry}\n     */\n\n  }, {\n    key: \"mergeBufferGeometries\",\n    value: function mergeBufferGeometries(geometries) {\n      var useGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var isIndexed = geometries[0].index !== null;\n      var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n      var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n      var attributes = {};\n      var morphAttributes = {};\n      var morphTargetsRelative = geometries[0].morphTargetsRelative;\n      var mergedGeometry = new BufferGeometry();\n      var offset = 0;\n\n      for (var i = 0; i < geometries.length; ++i) {\n        var geometry = geometries[i];\n        var attributesCount = 0; // ensure that all geometries are indexed, or none\n\n        if (isIndexed !== (geometry.index !== null)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n          return null;\n        } // gather attributes, exit early if they're different\n\n\n        for (var name in geometry.attributes) {\n          if (!attributesUsed.has(name)) {\n            console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n            return null;\n          }\n\n          if (attributes[name] === undefined) attributes[name] = [];\n          attributes[name].push(geometry.attributes[name]);\n          attributesCount++;\n        } // ensure geometries have the same number of attributes\n\n\n        if (attributesCount !== attributesUsed.size) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n          return null;\n        } // gather morph attributes, exit early if they're different\n\n\n        if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n          return null;\n        }\n\n        for (var _name in geometry.morphAttributes) {\n          if (!morphAttributesUsed.has(_name)) {\n            console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n            return null;\n          }\n\n          if (morphAttributes[_name] === undefined) morphAttributes[_name] = [];\n\n          morphAttributes[_name].push(geometry.morphAttributes[_name]);\n        } // gather .userData\n\n\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n        if (useGroups) {\n          var count = void 0;\n\n          if (isIndexed) {\n            count = geometry.index.count;\n          } else if (geometry.attributes.position !== undefined) {\n            count = geometry.attributes.position.count;\n          } else {\n            console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n            return null;\n          }\n\n          mergedGeometry.addGroup(offset, count, i);\n          offset += count;\n        }\n      } // merge indices\n\n\n      if (isIndexed) {\n        var indexOffset = 0;\n        var mergedIndex = [];\n\n        for (var _i = 0; _i < geometries.length; ++_i) {\n          var index = geometries[_i].index;\n\n          for (var j = 0; j < index.count; ++j) {\n            mergedIndex.push(index.getX(j) + indexOffset);\n          }\n\n          indexOffset += geometries[_i].attributes.position.count;\n        }\n\n        mergedGeometry.setIndex(mergedIndex);\n      } // merge attributes\n\n\n      for (var _name2 in attributes) {\n        var mergedAttribute = this.mergeBufferAttributes(attributes[_name2]);\n\n        if (!mergedAttribute) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + _name2 + ' attribute.');\n          return null;\n        }\n\n        mergedGeometry.setAttribute(_name2, mergedAttribute);\n      } // merge morph attributes\n\n\n      for (var _name3 in morphAttributes) {\n        var numMorphTargets = morphAttributes[_name3][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[_name3] = [];\n\n        for (var _i2 = 0; _i2 < numMorphTargets; ++_i2) {\n          var morphAttributesToMerge = [];\n\n          for (var _j = 0; _j < morphAttributes[_name3].length; ++_j) {\n            morphAttributesToMerge.push(morphAttributes[_name3][_j][_i2]);\n          }\n\n          var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n\n          if (!mergedMorphAttribute) {\n            console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + _name3 + ' morphAttribute.');\n            return null;\n          }\n\n          mergedGeometry.morphAttributes[_name3].push(mergedMorphAttribute);\n        }\n      }\n\n      return mergedGeometry;\n    }\n    /**\n     * @param {Array<BufferAttribute>} attributes\n     * @return {BufferAttribute}\n     */\n\n  }, {\n    key: \"mergeBufferAttributes\",\n    value: function mergeBufferAttributes(attributes) {\n      var TypedArray;\n      var itemSize;\n      var normalized;\n      var arrayLength = 0;\n\n      for (var i = 0; i < attributes.length; ++i) {\n        var attribute = attributes[i];\n\n        if (attribute.isInterleavedBufferAttribute) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n          return null;\n        }\n\n        if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n        if (TypedArray !== attribute.array.constructor) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n          return null;\n        }\n\n        if (itemSize === undefined) itemSize = attribute.itemSize;\n\n        if (itemSize !== attribute.itemSize) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n          return null;\n        }\n\n        if (normalized === undefined) normalized = attribute.normalized;\n\n        if (normalized !== attribute.normalized) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n          return null;\n        }\n\n        arrayLength += attribute.array.length;\n      }\n\n      var array = new TypedArray(arrayLength);\n      var offset = 0;\n\n      for (var _i3 = 0; _i3 < attributes.length; ++_i3) {\n        array.set(attributes[_i3].array, offset);\n        offset += attributes[_i3].array.length;\n      }\n\n      return new BufferAttribute(array, itemSize, normalized);\n    }\n    /**\n     * @param {Array<BufferAttribute>} attributes\n     * @return {Array<InterleavedBufferAttribute>}\n     */\n\n  }, {\n    key: \"interleaveAttributes\",\n    value: function interleaveAttributes(attributes) {\n      // Interleaves the provided attributes into an InterleavedBuffer and returns\n      // a set of InterleavedBufferAttributes for each attribute\n      var TypedArray;\n      var arrayLength = 0;\n      var stride = 0; // calculate the the length and type of the interleavedBuffer\n\n      for (var i = 0, l = attributes.length; i < l; ++i) {\n        var attribute = attributes[i];\n        if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n        if (TypedArray !== attribute.array.constructor) {\n          console.error('AttributeBuffers of different types cannot be interleaved');\n          return null;\n        }\n\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n      } // Create the set of buffer attributes\n\n\n      var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n      var offset = 0;\n      var res = [];\n      var getters = ['getX', 'getY', 'getZ', 'getW'];\n      var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n      for (var j = 0, _l = attributes.length; j < _l; j++) {\n        var _attribute = attributes[j];\n        var itemSize = _attribute.itemSize;\n        var count = _attribute.count;\n        var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, _attribute.normalized);\n        res.push(iba);\n        offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n        // at the appropriate offset\n\n        for (var c = 0; c < count; c++) {\n          for (var k = 0; k < itemSize; k++) {\n            iba[setters[k]](c, _attribute[getters[k]](c));\n          }\n        }\n      }\n\n      return res;\n    }\n    /**\n     * @param {Array<BufferGeometry>} geometry\n     * @return {number}\n     */\n\n  }, {\n    key: \"estimateBytesUsed\",\n    value: function estimateBytesUsed(geometry) {\n      // Return the estimated memory used by this geometry in bytes\n      // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n      // for InterleavedBufferAttributes.\n      var mem = 0;\n\n      for (var name in geometry.attributes) {\n        var attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n      }\n\n      var indices = geometry.getIndex();\n      mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n      return mem;\n    }\n    /**\n     * @param {BufferGeometry} geometry\n     * @param {number} tolerance\n     * @return {BufferGeometry>}\n     */\n\n  }, {\n    key: \"mergeVertices\",\n    value: function mergeVertices(geometry) {\n      var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n      tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n      // if it's already available.\n\n      var hashToIndex = {};\n      var indices = geometry.getIndex();\n      var positions = geometry.getAttribute('position');\n      var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n      var nextIndex = 0; // attributes and new attribute arrays\n\n      var attributeNames = Object.keys(geometry.attributes);\n      var attrArrays = {};\n      var morphAttrsArrays = {};\n      var newIndices = [];\n      var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n      for (var i = 0, l = attributeNames.length; i < l; i++) {\n        var name = attributeNames[i];\n        attrArrays[name] = [];\n        var morphAttr = geometry.morphAttributes[name];\n\n        if (morphAttr) {\n          morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(function () {\n            return [];\n          });\n        }\n      } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n      var decimalShift = Math.log10(1 / tolerance);\n      var shiftMultiplier = Math.pow(10, decimalShift);\n\n      for (var _i4 = 0; _i4 < vertexCount; _i4++) {\n        var index = indices ? indices.getX(_i4) : _i4; // Generate a hash for the vertex attributes at the current index 'i'\n\n        var hash = '';\n\n        for (var j = 0, _l2 = attributeNames.length; j < _l2; j++) {\n          var _name4 = attributeNames[j];\n          var attribute = geometry.getAttribute(_name4);\n          var itemSize = attribute.itemSize;\n\n          for (var k = 0; k < itemSize; k++) {\n            // double tilde truncates the decimal value\n            hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n          }\n        } // Add another reference to the vertex if it's already\n        // used by another index\n\n\n        if (hash in hashToIndex) {\n          newIndices.push(hashToIndex[hash]);\n        } else {\n          // copy data to the new index in the attribute arrays\n          for (var _j2 = 0, _l3 = attributeNames.length; _j2 < _l3; _j2++) {\n            var _name5 = attributeNames[_j2];\n\n            var _attribute2 = geometry.getAttribute(_name5);\n\n            var _morphAttr = geometry.morphAttributes[_name5];\n            var _itemSize = _attribute2.itemSize;\n            var newarray = attrArrays[_name5];\n            var newMorphArrays = morphAttrsArrays[_name5];\n\n            for (var _k = 0; _k < _itemSize; _k++) {\n              var getterFunc = getters[_k];\n              newarray.push(_attribute2[getterFunc](index));\n\n              if (_morphAttr) {\n                for (var m = 0, ml = _morphAttr.length; m < ml; m++) {\n                  newMorphArrays[m].push(_morphAttr[m][getterFunc](index));\n                }\n              }\n            }\n          }\n\n          hashToIndex[hash] = nextIndex;\n          newIndices.push(nextIndex);\n          nextIndex++;\n        }\n      } // Generate typed arrays from new attribute arrays and update\n      // the attributeBuffers\n\n\n      var result = geometry.clone();\n\n      for (var _i5 = 0, _l4 = attributeNames.length; _i5 < _l4; _i5++) {\n        var _name6 = attributeNames[_i5];\n        var oldAttribute = geometry.getAttribute(_name6);\n        var buffer = new oldAttribute.array.constructor(attrArrays[_name6]);\n\n        var _attribute3 = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n\n        result.setAttribute(_name6, _attribute3); // Update the attribute arrays\n\n        if (_name6 in morphAttrsArrays) {\n          for (var _j3 = 0; _j3 < morphAttrsArrays[_name6].length; _j3++) {\n            var oldMorphAttribute = geometry.morphAttributes[_name6][_j3];\n\n            var _buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[_name6][_j3]);\n\n            var morphAttribute = new BufferAttribute(_buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n            result.morphAttributes[_name6][_j3] = morphAttribute;\n          }\n        }\n      } // indices\n\n\n      result.setIndex(newIndices);\n      return result;\n    }\n    /**\n     * @param {BufferGeometry} geometry\n     * @param {number} drawMode\n     * @return {BufferGeometry>}\n     */\n\n  }, {\n    key: \"toTrianglesDrawMode\",\n    value: function toTrianglesDrawMode(geometry, drawMode) {\n      if (drawMode === TrianglesDrawMode) {\n        console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n        return geometry;\n      }\n\n      if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n        var index = geometry.getIndex(); // generate index if not present\n\n        if (index === null) {\n          var indices = [];\n          var position = geometry.getAttribute('position');\n\n          if (position !== undefined) {\n            for (var i = 0; i < position.count; i++) {\n              indices.push(i);\n            }\n\n            geometry.setIndex(indices);\n            index = geometry.getIndex();\n          } else {\n            console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n            return geometry;\n          }\n        } //\n\n\n        var numberOfTriangles = index.count - 2;\n        var newIndices = [];\n\n        if (drawMode === TriangleFanDrawMode) {\n          // gl.TRIANGLE_FAN\n          for (var _i6 = 1; _i6 <= numberOfTriangles; _i6++) {\n            newIndices.push(index.getX(0));\n            newIndices.push(index.getX(_i6));\n            newIndices.push(index.getX(_i6 + 1));\n          }\n        } else {\n          // gl.TRIANGLE_STRIP\n          for (var _i7 = 0; _i7 < numberOfTriangles; _i7++) {\n            if (_i7 % 2 === 0) {\n              newIndices.push(index.getX(_i7));\n              newIndices.push(index.getX(_i7 + 1));\n              newIndices.push(index.getX(_i7 + 2));\n            } else {\n              newIndices.push(index.getX(_i7 + 2));\n              newIndices.push(index.getX(_i7 + 1));\n              newIndices.push(index.getX(_i7));\n            }\n          }\n        }\n\n        if (newIndices.length / 3 !== numberOfTriangles) {\n          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n        } // build final geometry\n\n\n        var newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n        return geometry;\n      }\n    }\n    /**\n     * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n     * Helpful for Raytracing or Decals.\n     * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n     * @return {Object} An Object with original position/normal attributes and morphed ones.\n     */\n\n  }, {\n    key: \"computeMorphedAttributes\",\n    value: function computeMorphedAttributes(object) {\n      if (object.geometry.isBufferGeometry !== true) {\n        console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n        return null;\n      }\n\n      var _vA = new Vector3();\n\n      var _vB = new Vector3();\n\n      var _vC = new Vector3();\n\n      var _tempA = new Vector3();\n\n      var _tempB = new Vector3();\n\n      var _tempC = new Vector3();\n\n      var _morphA = new Vector3();\n\n      var _morphB = new Vector3();\n\n      var _morphC = new Vector3();\n\n      function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a);\n\n        _vB.fromBufferAttribute(attribute, b);\n\n        _vC.fromBufferAttribute(attribute, c);\n\n        var morphInfluences = object.morphTargetInfluences;\n\n        if (material.morphTargets && morphAttribute && morphInfluences) {\n          _morphA.set(0, 0, 0);\n\n          _morphB.set(0, 0, 0);\n\n          _morphC.set(0, 0, 0);\n\n          for (var _i8 = 0, _il = morphAttribute.length; _i8 < _il; _i8++) {\n            var influence = morphInfluences[_i8];\n            var morph = morphAttribute[_i8];\n            if (influence === 0) continue;\n\n            _tempA.fromBufferAttribute(morph, a);\n\n            _tempB.fromBufferAttribute(morph, b);\n\n            _tempC.fromBufferAttribute(morph, c);\n\n            if (morphTargetsRelative) {\n              _morphA.addScaledVector(_tempA, influence);\n\n              _morphB.addScaledVector(_tempB, influence);\n\n              _morphC.addScaledVector(_tempC, influence);\n            } else {\n              _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n              _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n              _morphC.addScaledVector(_tempC.sub(_vC), influence);\n            }\n          }\n\n          _vA.add(_morphA);\n\n          _vB.add(_morphB);\n\n          _vC.add(_morphC);\n        }\n\n        if (object.isSkinnedMesh) {\n          object.boneTransform(a, _vA);\n          object.boneTransform(b, _vB);\n          object.boneTransform(c, _vC);\n        }\n\n        modifiedAttributeArray[a * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c * 3 + 2] = _vC.z;\n      }\n\n      var geometry = object.geometry;\n      var material = object.material;\n      var a, b, c;\n      var index = geometry.index;\n      var positionAttribute = geometry.attributes.position;\n      var morphPosition = geometry.morphAttributes.position;\n      var morphTargetsRelative = geometry.morphTargetsRelative;\n      var normalAttribute = geometry.attributes.normal;\n      var morphNormal = geometry.morphAttributes.position;\n      var groups = geometry.groups;\n      var drawRange = geometry.drawRange;\n      var i, j, il, jl;\n      var group, groupMaterial;\n      var start, end;\n      var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n      var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n      if (index !== null) {\n        // indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (i = 0, il = groups.length; i < il; i++) {\n            group = groups[i];\n            groupMaterial = material[group.materialIndex];\n            start = Math.max(group.start, drawRange.start);\n            end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n            for (j = start, jl = end; j < jl; j += 3) {\n              a = index.getX(j);\n              b = index.getX(j + 1);\n              c = index.getX(j + 2);\n\n              _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n              _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n          }\n        } else {\n          start = Math.max(0, drawRange.start);\n          end = Math.min(index.count, drawRange.start + drawRange.count);\n\n          for (i = start, il = end; i < il; i += 3) {\n            a = index.getX(i);\n            b = index.getX(i + 1);\n            c = index.getX(i + 2);\n\n            _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n            _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n          }\n        }\n      } else if (positionAttribute !== undefined) {\n        // non-indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (i = 0, il = groups.length; i < il; i++) {\n            group = groups[i];\n            groupMaterial = material[group.materialIndex];\n            start = Math.max(group.start, drawRange.start);\n            end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n            for (j = start, jl = end; j < jl; j += 3) {\n              a = j;\n              b = j + 1;\n              c = j + 2;\n\n              _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n              _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n          }\n        } else {\n          start = Math.max(0, drawRange.start);\n          end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n          for (i = start, il = end; i < il; i += 3) {\n            a = i;\n            b = i + 1;\n            c = i + 2;\n\n            _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n            _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n          }\n        }\n      }\n\n      var morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n      var morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n      return {\n        positionAttribute: positionAttribute,\n        normalAttribute: normalAttribute,\n        morphedPositionAttribute: morphedPositionAttribute,\n        morphedNormalAttribute: morphedNormalAttribute\n      };\n    }\n  }]);\n\n  return BufferGeometryUtils;\n}();\n\nexport { BufferGeometryUtils };","map":{"version":3,"sources":["/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"names":["BufferAttribute","BufferGeometry","Float32BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector3","BufferGeometryUtils","geometry","computeTangents","console","warn","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","i","length","attributesCount","error","name","has","undefined","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","array","constructor","set","stride","l","interleavedBuffer","res","getters","setters","iba","c","k","mem","attr","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","drawMode","numberOfTriangles","newGeometry","clearGroups","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","material","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","il","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","jl","group","groupMaterial","start","end","modifiedPosition","Float32Array","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute"],"mappings":";;AAAA,SACCA,eADD,EAECC,cAFD,EAGCC,sBAHD,EAICC,iBAJD,EAKCC,0BALD,EAMCC,mBAND,EAOCC,qBAPD,EAQCC,iBARD,EASCC,OATD,QAUO,OAVP;;IAYMC,mB;;;;;;;WAEL,yBAAwBC,QAAxB,EAAmC;AAElCA,MAAAA,QAAQ,CAACC,eAAT;AACAC,MAAAA,OAAO,CAACC,IAAR,CAAc,+GAAd;AAEA;AAED;AACD;AACA;AACA;AACA;;;;WACC,+BAA8BC,UAA9B,EAA8D;AAAA,UAApBC,SAAoB,uEAAR,KAAQ;AAE7D,UAAMC,SAAS,GAAGF,UAAU,CAAE,CAAF,CAAV,CAAgBG,KAAhB,KAA0B,IAA5C;AAEA,UAAMC,cAAc,GAAG,IAAIC,GAAJ,CAASC,MAAM,CAACC,IAAP,CAAaP,UAAU,CAAE,CAAF,CAAV,CAAgBQ,UAA7B,CAAT,CAAvB;AACA,UAAMC,mBAAmB,GAAG,IAAIJ,GAAJ,CAASC,MAAM,CAACC,IAAP,CAAaP,UAAU,CAAE,CAAF,CAAV,CAAgBU,eAA7B,CAAT,CAA5B;AAEA,UAAMF,UAAU,GAAG,EAAnB;AACA,UAAME,eAAe,GAAG,EAAxB;AAEA,UAAMC,oBAAoB,GAAGX,UAAU,CAAE,CAAF,CAAV,CAAgBW,oBAA7C;AAEA,UAAMC,cAAc,GAAG,IAAIzB,cAAJ,EAAvB;AAEA,UAAI0B,MAAM,GAAG,CAAb;;AAEA,WAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGd,UAAU,CAACe,MAAhC,EAAwC,EAAGD,CAA3C,EAA+C;AAE9C,YAAMlB,QAAQ,GAAGI,UAAU,CAAEc,CAAF,CAA3B;AACA,YAAIE,eAAe,GAAG,CAAtB,CAH8C,CAK9C;;AAEA,YAAKd,SAAS,MAAON,QAAQ,CAACO,KAAT,KAAmB,IAA1B,CAAd,EAAiD;AAEhDL,UAAAA,OAAO,CAACmB,KAAR,CAAe,uFAAuFH,CAAvF,GAA2F,8HAA1G;AACA,iBAAO,IAAP;AAEA,SAZ6C,CAc9C;;;AAEA,aAAM,IAAMI,IAAZ,IAAoBtB,QAAQ,CAACY,UAA7B,EAA0C;AAEzC,cAAK,CAAEJ,cAAc,CAACe,GAAf,CAAoBD,IAApB,CAAP,EAAoC;AAEnCpB,YAAAA,OAAO,CAACmB,KAAR,CAAe,uFAAuFH,CAAvF,GAA2F,+DAA3F,GAA6JI,IAA7J,GAAoK,8DAAnL;AACA,mBAAO,IAAP;AAEA;;AAED,cAAKV,UAAU,CAAEU,IAAF,CAAV,KAAuBE,SAA5B,EAAwCZ,UAAU,CAAEU,IAAF,CAAV,GAAqB,EAArB;AAExCV,UAAAA,UAAU,CAAEU,IAAF,CAAV,CAAmBG,IAAnB,CAAyBzB,QAAQ,CAACY,UAAT,CAAqBU,IAArB,CAAzB;AAEAF,UAAAA,eAAe;AAEf,SA/B6C,CAiC9C;;;AAEA,YAAKA,eAAe,KAAKZ,cAAc,CAACkB,IAAxC,EAA+C;AAE9CxB,UAAAA,OAAO,CAACmB,KAAR,CAAe,uFAAuFH,CAAvF,GAA2F,gEAA1G;AACA,iBAAO,IAAP;AAEA,SAxC6C,CA0C9C;;;AAEA,YAAKH,oBAAoB,KAAKf,QAAQ,CAACe,oBAAvC,EAA8D;AAE7Db,UAAAA,OAAO,CAACmB,KAAR,CAAe,uFAAuFH,CAAvF,GAA2F,uEAA1G;AACA,iBAAO,IAAP;AAEA;;AAED,aAAM,IAAMI,KAAZ,IAAoBtB,QAAQ,CAACc,eAA7B,EAA+C;AAE9C,cAAK,CAAED,mBAAmB,CAACU,GAApB,CAAyBD,KAAzB,CAAP,EAAyC;AAExCpB,YAAAA,OAAO,CAACmB,KAAR,CAAe,uFAAuFH,CAAvF,GAA2F,mEAA1G;AACA,mBAAO,IAAP;AAEA;;AAED,cAAKJ,eAAe,CAAEQ,KAAF,CAAf,KAA4BE,SAAjC,EAA6CV,eAAe,CAAEQ,KAAF,CAAf,GAA0B,EAA1B;;AAE7CR,UAAAA,eAAe,CAAEQ,KAAF,CAAf,CAAwBG,IAAxB,CAA8BzB,QAAQ,CAACc,eAAT,CAA0BQ,KAA1B,CAA9B;AAEA,SAhE6C,CAkE9C;;;AAEAN,QAAAA,cAAc,CAACW,QAAf,CAAwBC,cAAxB,GAAyCZ,cAAc,CAACW,QAAf,CAAwBC,cAAxB,IAA0C,EAAnF;AACAZ,QAAAA,cAAc,CAACW,QAAf,CAAwBC,cAAxB,CAAuCH,IAAvC,CAA6CzB,QAAQ,CAAC2B,QAAtD;;AAEA,YAAKtB,SAAL,EAAiB;AAEhB,cAAIwB,KAAK,SAAT;;AAEA,cAAKvB,SAAL,EAAiB;AAEhBuB,YAAAA,KAAK,GAAG7B,QAAQ,CAACO,KAAT,CAAesB,KAAvB;AAEA,WAJD,MAIO,IAAK7B,QAAQ,CAACY,UAAT,CAAoBkB,QAApB,KAAiCN,SAAtC,EAAkD;AAExDK,YAAAA,KAAK,GAAG7B,QAAQ,CAACY,UAAT,CAAoBkB,QAApB,CAA6BD,KAArC;AAEA,WAJM,MAIA;AAEN3B,YAAAA,OAAO,CAACmB,KAAR,CAAe,uFAAuFH,CAAvF,GAA2F,kEAA1G;AACA,mBAAO,IAAP;AAEA;;AAEDF,UAAAA,cAAc,CAACe,QAAf,CAAyBd,MAAzB,EAAiCY,KAAjC,EAAwCX,CAAxC;AAEAD,UAAAA,MAAM,IAAIY,KAAV;AAEA;AAED,OAhH4D,CAkH7D;;;AAEA,UAAKvB,SAAL,EAAiB;AAEhB,YAAI0B,WAAW,GAAG,CAAlB;AACA,YAAMC,WAAW,GAAG,EAApB;;AAEA,aAAM,IAAIf,EAAC,GAAG,CAAd,EAAiBA,EAAC,GAAGd,UAAU,CAACe,MAAhC,EAAwC,EAAGD,EAA3C,EAA+C;AAE9C,cAAMX,KAAK,GAAGH,UAAU,CAAEc,EAAF,CAAV,CAAgBX,KAA9B;;AAEA,eAAM,IAAI2B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG3B,KAAK,CAACsB,KAA3B,EAAkC,EAAGK,CAArC,EAAyC;AAExCD,YAAAA,WAAW,CAACR,IAAZ,CAAkBlB,KAAK,CAAC4B,IAAN,CAAYD,CAAZ,IAAkBF,WAApC;AAEA;;AAEDA,UAAAA,WAAW,IAAI5B,UAAU,CAAEc,EAAF,CAAV,CAAgBN,UAAhB,CAA2BkB,QAA3B,CAAoCD,KAAnD;AAEA;;AAEDb,QAAAA,cAAc,CAACoB,QAAf,CAAyBH,WAAzB;AAEA,OAzI4D,CA2I7D;;;AAEA,WAAM,IAAMX,MAAZ,IAAoBV,UAApB,EAAiC;AAEhC,YAAMyB,eAAe,GAAG,KAAKC,qBAAL,CAA4B1B,UAAU,CAAEU,MAAF,CAAtC,CAAxB;;AAEA,YAAK,CAAEe,eAAP,EAAyB;AAExBnC,UAAAA,OAAO,CAACmB,KAAR,CAAe,0FAA0FC,MAA1F,GAAiG,aAAhH;AACA,iBAAO,IAAP;AAEA;;AAEDN,QAAAA,cAAc,CAACuB,YAAf,CAA6BjB,MAA7B,EAAmCe,eAAnC;AAEA,OA1J4D,CA4J7D;;;AAEA,WAAM,IAAMf,MAAZ,IAAoBR,eAApB,EAAsC;AAErC,YAAM0B,eAAe,GAAG1B,eAAe,CAAEQ,MAAF,CAAf,CAAyB,CAAzB,EAA6BH,MAArD;AAEA,YAAKqB,eAAe,KAAK,CAAzB,EAA6B;AAE7BxB,QAAAA,cAAc,CAACF,eAAf,GAAiCE,cAAc,CAACF,eAAf,IAAkC,EAAnE;AACAE,QAAAA,cAAc,CAACF,eAAf,CAAgCQ,MAAhC,IAAyC,EAAzC;;AAEA,aAAM,IAAIJ,GAAC,GAAG,CAAd,EAAiBA,GAAC,GAAGsB,eAArB,EAAsC,EAAGtB,GAAzC,EAA6C;AAE5C,cAAMuB,sBAAsB,GAAG,EAA/B;;AAEA,eAAM,IAAIP,EAAC,GAAG,CAAd,EAAiBA,EAAC,GAAGpB,eAAe,CAAEQ,MAAF,CAAf,CAAwBH,MAA7C,EAAqD,EAAGe,EAAxD,EAA4D;AAE3DO,YAAAA,sBAAsB,CAAChB,IAAvB,CAA6BX,eAAe,CAAEQ,MAAF,CAAf,CAAyBY,EAAzB,EAA8BhB,GAA9B,CAA7B;AAEA;;AAED,cAAMwB,oBAAoB,GAAG,KAAKJ,qBAAL,CAA4BG,sBAA5B,CAA7B;;AAEA,cAAK,CAAEC,oBAAP,EAA8B;AAE7BxC,YAAAA,OAAO,CAACmB,KAAR,CAAe,0FAA0FC,MAA1F,GAAiG,kBAAhH;AACA,mBAAO,IAAP;AAEA;;AAEDN,UAAAA,cAAc,CAACF,eAAf,CAAgCQ,MAAhC,EAAuCG,IAAvC,CAA6CiB,oBAA7C;AAEA;AAED;;AAED,aAAO1B,cAAP;AAEA;AAED;AACD;AACA;AACA;;;;WACC,+BAA8BJ,UAA9B,EAA2C;AAE1C,UAAI+B,UAAJ;AACA,UAAIC,QAAJ;AACA,UAAIC,UAAJ;AACA,UAAIC,WAAW,GAAG,CAAlB;;AAEA,WAAM,IAAI5B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGN,UAAU,CAACO,MAAhC,EAAwC,EAAGD,CAA3C,EAA+C;AAE9C,YAAM6B,SAAS,GAAGnC,UAAU,CAAEM,CAAF,CAA5B;;AAEA,YAAK6B,SAAS,CAACC,4BAAf,EAA8C;AAE7C9C,UAAAA,OAAO,CAACmB,KAAR,CAAe,4GAAf;AACA,iBAAO,IAAP;AAEA;;AAED,YAAKsB,UAAU,KAAKnB,SAApB,EAAgCmB,UAAU,GAAGI,SAAS,CAACE,KAAV,CAAgBC,WAA7B;;AAChC,YAAKP,UAAU,KAAKI,SAAS,CAACE,KAAV,CAAgBC,WAApC,EAAkD;AAEjDhD,UAAAA,OAAO,CAACmB,KAAR,CAAe,iJAAf;AACA,iBAAO,IAAP;AAEA;;AAED,YAAKuB,QAAQ,KAAKpB,SAAlB,EAA8BoB,QAAQ,GAAGG,SAAS,CAACH,QAArB;;AAC9B,YAAKA,QAAQ,KAAKG,SAAS,CAACH,QAA5B,EAAuC;AAEtC1C,UAAAA,OAAO,CAACmB,KAAR,CAAe,qIAAf;AACA,iBAAO,IAAP;AAEA;;AAED,YAAKwB,UAAU,KAAKrB,SAApB,EAAgCqB,UAAU,GAAGE,SAAS,CAACF,UAAvB;;AAChC,YAAKA,UAAU,KAAKE,SAAS,CAACF,UAA9B,EAA2C;AAE1C3C,UAAAA,OAAO,CAACmB,KAAR,CAAe,uIAAf;AACA,iBAAO,IAAP;AAEA;;AAEDyB,QAAAA,WAAW,IAAIC,SAAS,CAACE,KAAV,CAAgB9B,MAA/B;AAEA;;AAED,UAAM8B,KAAK,GAAG,IAAIN,UAAJ,CAAgBG,WAAhB,CAAd;AACA,UAAI7B,MAAM,GAAG,CAAb;;AAEA,WAAM,IAAIC,GAAC,GAAG,CAAd,EAAiBA,GAAC,GAAGN,UAAU,CAACO,MAAhC,EAAwC,EAAGD,GAA3C,EAA+C;AAE9C+B,QAAAA,KAAK,CAACE,GAAN,CAAWvC,UAAU,CAAEM,GAAF,CAAV,CAAgB+B,KAA3B,EAAkChC,MAAlC;AAEAA,QAAAA,MAAM,IAAIL,UAAU,CAAEM,GAAF,CAAV,CAAgB+B,KAAhB,CAAsB9B,MAAhC;AAEA;;AAED,aAAO,IAAI7B,eAAJ,CAAqB2D,KAArB,EAA4BL,QAA5B,EAAsCC,UAAtC,CAAP;AAEA;AAED;AACD;AACA;AACA;;;;WACC,8BAA6BjC,UAA7B,EAA0C;AAEzC;AACA;AACA,UAAI+B,UAAJ;AACA,UAAIG,WAAW,GAAG,CAAlB;AACA,UAAIM,MAAM,GAAG,CAAb,CANyC,CAQzC;;AACA,WAAM,IAAIlC,CAAC,GAAG,CAAR,EAAWmC,CAAC,GAAGzC,UAAU,CAACO,MAAhC,EAAwCD,CAAC,GAAGmC,CAA5C,EAA+C,EAAGnC,CAAlD,EAAsD;AAErD,YAAM6B,SAAS,GAAGnC,UAAU,CAAEM,CAAF,CAA5B;AAEA,YAAKyB,UAAU,KAAKnB,SAApB,EAAgCmB,UAAU,GAAGI,SAAS,CAACE,KAAV,CAAgBC,WAA7B;;AAChC,YAAKP,UAAU,KAAKI,SAAS,CAACE,KAAV,CAAgBC,WAApC,EAAkD;AAEjDhD,UAAAA,OAAO,CAACmB,KAAR,CAAe,2DAAf;AACA,iBAAO,IAAP;AAEA;;AAEDyB,QAAAA,WAAW,IAAIC,SAAS,CAACE,KAAV,CAAgB9B,MAA/B;AACAiC,QAAAA,MAAM,IAAIL,SAAS,CAACH,QAApB;AAEA,OAxBwC,CA0BzC;;;AACA,UAAMU,iBAAiB,GAAG,IAAI7D,iBAAJ,CAAuB,IAAIkD,UAAJ,CAAgBG,WAAhB,CAAvB,EAAsDM,MAAtD,CAA1B;AACA,UAAInC,MAAM,GAAG,CAAb;AACA,UAAMsC,GAAG,GAAG,EAAZ;AACA,UAAMC,OAAO,GAAG,CAAE,MAAF,EAAU,MAAV,EAAkB,MAAlB,EAA0B,MAA1B,CAAhB;AACA,UAAMC,OAAO,GAAG,CAAE,MAAF,EAAU,MAAV,EAAkB,MAAlB,EAA0B,MAA1B,CAAhB;;AAEA,WAAM,IAAIvB,CAAC,GAAG,CAAR,EAAWmB,EAAC,GAAGzC,UAAU,CAACO,MAAhC,EAAwCe,CAAC,GAAGmB,EAA5C,EAA+CnB,CAAC,EAAhD,EAAsD;AAErD,YAAMa,UAAS,GAAGnC,UAAU,CAAEsB,CAAF,CAA5B;AACA,YAAMU,QAAQ,GAAGG,UAAS,CAACH,QAA3B;AACA,YAAMf,KAAK,GAAGkB,UAAS,CAAClB,KAAxB;AACA,YAAM6B,GAAG,GAAG,IAAIhE,0BAAJ,CAAgC4D,iBAAhC,EAAmDV,QAAnD,EAA6D3B,MAA7D,EAAqE8B,UAAS,CAACF,UAA/E,CAAZ;AACAU,QAAAA,GAAG,CAAC9B,IAAJ,CAAUiC,GAAV;AAEAzC,QAAAA,MAAM,IAAI2B,QAAV,CARqD,CAUrD;AACA;;AACA,aAAM,IAAIe,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG9B,KAArB,EAA4B8B,CAAC,EAA7B,EAAmC;AAElC,eAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGhB,QAArB,EAA+BgB,CAAC,EAAhC,EAAsC;AAErCF,YAAAA,GAAG,CAAED,OAAO,CAAEG,CAAF,CAAT,CAAH,CAAqBD,CAArB,EAAwBZ,UAAS,CAAES,OAAO,CAAEI,CAAF,CAAT,CAAT,CAA2BD,CAA3B,CAAxB;AAEA;AAED;AAED;;AAED,aAAOJ,GAAP;AAEA;AAED;AACD;AACA;AACA;;;;WACC,2BAA0BvD,QAA1B,EAAqC;AAEpC;AACA;AACA;AACA,UAAI6D,GAAG,GAAG,CAAV;;AACA,WAAM,IAAMvC,IAAZ,IAAoBtB,QAAQ,CAACY,UAA7B,EAA0C;AAEzC,YAAMkD,IAAI,GAAG9D,QAAQ,CAAC+D,YAAT,CAAuBzC,IAAvB,CAAb;AACAuC,QAAAA,GAAG,IAAIC,IAAI,CAACjC,KAAL,GAAaiC,IAAI,CAAClB,QAAlB,GAA6BkB,IAAI,CAACb,KAAL,CAAWe,iBAA/C;AAEA;;AAED,UAAMC,OAAO,GAAGjE,QAAQ,CAACkE,QAAT,EAAhB;AACAL,MAAAA,GAAG,IAAII,OAAO,GAAGA,OAAO,CAACpC,KAAR,GAAgBoC,OAAO,CAACrB,QAAxB,GAAmCqB,OAAO,CAAChB,KAAR,CAAce,iBAApD,GAAwE,CAAtF;AACA,aAAOH,GAAP;AAEA;AAED;AACD;AACA;AACA;AACA;;;;WACC,uBAAsB7D,QAAtB,EAAmD;AAAA,UAAnBmE,SAAmB,uEAAP,IAAO;AAElDA,MAAAA,SAAS,GAAGC,IAAI,CAACC,GAAL,CAAUF,SAAV,EAAqBG,MAAM,CAACC,OAA5B,CAAZ,CAFkD,CAIlD;AACA;;AACA,UAAMC,WAAW,GAAG,EAApB;AACA,UAAMP,OAAO,GAAGjE,QAAQ,CAACkE,QAAT,EAAhB;AACA,UAAMO,SAAS,GAAGzE,QAAQ,CAAC+D,YAAT,CAAuB,UAAvB,CAAlB;AACA,UAAMW,WAAW,GAAGT,OAAO,GAAGA,OAAO,CAACpC,KAAX,GAAmB4C,SAAS,CAAC5C,KAAxD,CATkD,CAWlD;;AACA,UAAI8C,SAAS,GAAG,CAAhB,CAZkD,CAclD;;AACA,UAAMC,cAAc,GAAGlE,MAAM,CAACC,IAAP,CAAaX,QAAQ,CAACY,UAAtB,CAAvB;AACA,UAAMiE,UAAU,GAAG,EAAnB;AACA,UAAMC,gBAAgB,GAAG,EAAzB;AACA,UAAMC,UAAU,GAAG,EAAnB;AACA,UAAMvB,OAAO,GAAG,CAAE,MAAF,EAAU,MAAV,EAAkB,MAAlB,EAA0B,MAA1B,CAAhB,CAnBkD,CAqBlD;;AACA,WAAM,IAAItC,CAAC,GAAG,CAAR,EAAWmC,CAAC,GAAGuB,cAAc,CAACzD,MAApC,EAA4CD,CAAC,GAAGmC,CAAhD,EAAmDnC,CAAC,EAApD,EAA0D;AAEzD,YAAMI,IAAI,GAAGsD,cAAc,CAAE1D,CAAF,CAA3B;AAEA2D,QAAAA,UAAU,CAAEvD,IAAF,CAAV,GAAqB,EAArB;AAEA,YAAM0D,SAAS,GAAGhF,QAAQ,CAACc,eAAT,CAA0BQ,IAA1B,CAAlB;;AACA,YAAK0D,SAAL,EAAiB;AAEhBF,UAAAA,gBAAgB,CAAExD,IAAF,CAAhB,GAA2B,IAAI2D,KAAJ,CAAWD,SAAS,CAAC7D,MAArB,EAA8B+D,IAA9B,GAAqCC,GAArC,CAA0C;AAAA,mBAAM,EAAN;AAAA,WAA1C,CAA3B;AAEA;AAED,OAnCiD,CAqClD;;;AACA,UAAMC,YAAY,GAAGhB,IAAI,CAACiB,KAAL,CAAY,IAAIlB,SAAhB,CAArB;AACA,UAAMmB,eAAe,GAAGlB,IAAI,CAACmB,GAAL,CAAU,EAAV,EAAcH,YAAd,CAAxB;;AACA,WAAM,IAAIlE,GAAC,GAAG,CAAd,EAAiBA,GAAC,GAAGwD,WAArB,EAAkCxD,GAAC,EAAnC,EAAyC;AAExC,YAAMX,KAAK,GAAG0D,OAAO,GAAGA,OAAO,CAAC9B,IAAR,CAAcjB,GAAd,CAAH,GAAuBA,GAA5C,CAFwC,CAIxC;;AACA,YAAIsE,IAAI,GAAG,EAAX;;AACA,aAAM,IAAItD,CAAC,GAAG,CAAR,EAAWmB,GAAC,GAAGuB,cAAc,CAACzD,MAApC,EAA4Ce,CAAC,GAAGmB,GAAhD,EAAmDnB,CAAC,EAApD,EAA0D;AAEzD,cAAMZ,MAAI,GAAGsD,cAAc,CAAE1C,CAAF,CAA3B;AACA,cAAMa,SAAS,GAAG/C,QAAQ,CAAC+D,YAAT,CAAuBzC,MAAvB,CAAlB;AACA,cAAMsB,QAAQ,GAAGG,SAAS,CAACH,QAA3B;;AAEA,eAAM,IAAIgB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGhB,QAArB,EAA+BgB,CAAC,EAAhC,EAAsC;AAErC;AACA4B,YAAAA,IAAI,cAAQ,CAAE,EAAIzC,SAAS,CAAES,OAAO,CAAEI,CAAF,CAAT,CAAT,CAA2BrD,KAA3B,IAAqC+E,eAAzC,CAAV,MAAJ;AAEA;AAED,SAnBuC,CAqBxC;AACA;;;AACA,YAAKE,IAAI,IAAIhB,WAAb,EAA2B;AAE1BO,UAAAA,UAAU,CAACtD,IAAX,CAAiB+C,WAAW,CAAEgB,IAAF,CAA5B;AAEA,SAJD,MAIO;AAEN;AACA,eAAM,IAAItD,GAAC,GAAG,CAAR,EAAWmB,GAAC,GAAGuB,cAAc,CAACzD,MAApC,EAA4Ce,GAAC,GAAGmB,GAAhD,EAAmDnB,GAAC,EAApD,EAA0D;AAEzD,gBAAMZ,MAAI,GAAGsD,cAAc,CAAE1C,GAAF,CAA3B;;AACA,gBAAMa,WAAS,GAAG/C,QAAQ,CAAC+D,YAAT,CAAuBzC,MAAvB,CAAlB;;AACA,gBAAM0D,UAAS,GAAGhF,QAAQ,CAACc,eAAT,CAA0BQ,MAA1B,CAAlB;AACA,gBAAMsB,SAAQ,GAAGG,WAAS,CAACH,QAA3B;AACA,gBAAM6C,QAAQ,GAAGZ,UAAU,CAAEvD,MAAF,CAA3B;AACA,gBAAMoE,cAAc,GAAGZ,gBAAgB,CAAExD,MAAF,CAAvC;;AAEA,iBAAM,IAAIsC,EAAC,GAAG,CAAd,EAAiBA,EAAC,GAAGhB,SAArB,EAA+BgB,EAAC,EAAhC,EAAsC;AAErC,kBAAM+B,UAAU,GAAGnC,OAAO,CAAEI,EAAF,CAA1B;AACA6B,cAAAA,QAAQ,CAAChE,IAAT,CAAesB,WAAS,CAAE4C,UAAF,CAAT,CAAyBpF,KAAzB,CAAf;;AAEA,kBAAKyE,UAAL,EAAiB;AAEhB,qBAAM,IAAIY,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGb,UAAS,CAAC7D,MAAhC,EAAwCyE,CAAC,GAAGC,EAA5C,EAAgDD,CAAC,EAAjD,EAAuD;AAEtDF,kBAAAA,cAAc,CAAEE,CAAF,CAAd,CAAoBnE,IAApB,CAA0BuD,UAAS,CAAEY,CAAF,CAAT,CAAgBD,UAAhB,EAA8BpF,KAA9B,CAA1B;AAEA;AAED;AAED;AAED;;AAEDiE,UAAAA,WAAW,CAAEgB,IAAF,CAAX,GAAsBb,SAAtB;AACAI,UAAAA,UAAU,CAACtD,IAAX,CAAiBkD,SAAjB;AACAA,UAAAA,SAAS;AAET;AAED,OAxGiD,CA0GlD;AACA;;;AACA,UAAMmB,MAAM,GAAG9F,QAAQ,CAAC+F,KAAT,EAAf;;AACA,WAAM,IAAI7E,GAAC,GAAG,CAAR,EAAWmC,GAAC,GAAGuB,cAAc,CAACzD,MAApC,EAA4CD,GAAC,GAAGmC,GAAhD,EAAmDnC,GAAC,EAApD,EAA0D;AAEzD,YAAMI,MAAI,GAAGsD,cAAc,CAAE1D,GAAF,CAA3B;AACA,YAAM8E,YAAY,GAAGhG,QAAQ,CAAC+D,YAAT,CAAuBzC,MAAvB,CAArB;AAEA,YAAM2E,MAAM,GAAG,IAAID,YAAY,CAAC/C,KAAb,CAAmBC,WAAvB,CAAoC2B,UAAU,CAAEvD,MAAF,CAA9C,CAAf;;AACA,YAAMyB,WAAS,GAAG,IAAIzD,eAAJ,CAAqB2G,MAArB,EAA6BD,YAAY,CAACpD,QAA1C,EAAoDoD,YAAY,CAACnD,UAAjE,CAAlB;;AAEAiD,QAAAA,MAAM,CAACvD,YAAP,CAAqBjB,MAArB,EAA2ByB,WAA3B,EARyD,CAUzD;;AACA,YAAKzB,MAAI,IAAIwD,gBAAb,EAAgC;AAE/B,eAAM,IAAI5C,GAAC,GAAG,CAAd,EAAiBA,GAAC,GAAG4C,gBAAgB,CAAExD,MAAF,CAAhB,CAAyBH,MAA9C,EAAsDe,GAAC,EAAvD,EAA6D;AAE5D,gBAAMgE,iBAAiB,GAAGlG,QAAQ,CAACc,eAAT,CAA0BQ,MAA1B,EAAkCY,GAAlC,CAA1B;;AAEA,gBAAM+D,OAAM,GAAG,IAAIC,iBAAiB,CAACjD,KAAlB,CAAwBC,WAA5B,CAAyC4B,gBAAgB,CAAExD,MAAF,CAAhB,CAA0BY,GAA1B,CAAzC,CAAf;;AACA,gBAAMiE,cAAc,GAAG,IAAI7G,eAAJ,CAAqB2G,OAArB,EAA6BC,iBAAiB,CAACtD,QAA/C,EAAyDsD,iBAAiB,CAACrD,UAA3E,CAAvB;AACAiD,YAAAA,MAAM,CAAChF,eAAP,CAAwBQ,MAAxB,EAAgCY,GAAhC,IAAsCiE,cAAtC;AAEA;AAED;AAED,OAtIiD,CAwIlD;;;AAEAL,MAAAA,MAAM,CAAC1D,QAAP,CAAiB2C,UAAjB;AAEA,aAAOe,MAAP;AAEA;AAED;AACD;AACA;AACA;AACA;;;;WACC,6BAA4B9F,QAA5B,EAAsCoG,QAAtC,EAAiD;AAEhD,UAAKA,QAAQ,KAAKvG,iBAAlB,EAAsC;AAErCK,QAAAA,OAAO,CAACC,IAAR,CAAc,yFAAd;AACA,eAAOH,QAAP;AAEA;;AAED,UAAKoG,QAAQ,KAAKzG,mBAAb,IAAoCyG,QAAQ,KAAKxG,qBAAtD,EAA8E;AAE7E,YAAIW,KAAK,GAAGP,QAAQ,CAACkE,QAAT,EAAZ,CAF6E,CAI7E;;AAEA,YAAK3D,KAAK,KAAK,IAAf,EAAsB;AAErB,cAAM0D,OAAO,GAAG,EAAhB;AAEA,cAAMnC,QAAQ,GAAG9B,QAAQ,CAAC+D,YAAT,CAAuB,UAAvB,CAAjB;;AAEA,cAAKjC,QAAQ,KAAKN,SAAlB,EAA8B;AAE7B,iBAAM,IAAIN,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGY,QAAQ,CAACD,KAA9B,EAAqCX,CAAC,EAAtC,EAA4C;AAE3C+C,cAAAA,OAAO,CAACxC,IAAR,CAAcP,CAAd;AAEA;;AAEDlB,YAAAA,QAAQ,CAACoC,QAAT,CAAmB6B,OAAnB;AACA1D,YAAAA,KAAK,GAAGP,QAAQ,CAACkE,QAAT,EAAR;AAEA,WAXD,MAWO;AAENhE,YAAAA,OAAO,CAACmB,KAAR,CAAe,yGAAf;AACA,mBAAOrB,QAAP;AAEA;AAED,SA9B4E,CAgC7E;;;AAEA,YAAMqG,iBAAiB,GAAG9F,KAAK,CAACsB,KAAN,GAAc,CAAxC;AACA,YAAMkD,UAAU,GAAG,EAAnB;;AAEA,YAAKqB,QAAQ,KAAKzG,mBAAlB,EAAwC;AAEvC;AAEA,eAAM,IAAIuB,GAAC,GAAG,CAAd,EAAiBA,GAAC,IAAImF,iBAAtB,EAAyCnF,GAAC,EAA1C,EAAgD;AAE/C6D,YAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAY,CAAZ,CAAjB;AACA4C,YAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAYjB,GAAZ,CAAjB;AACA6D,YAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAYjB,GAAC,GAAG,CAAhB,CAAjB;AAEA;AAED,SAZD,MAYO;AAEN;AAEA,eAAM,IAAIA,GAAC,GAAG,CAAd,EAAiBA,GAAC,GAAGmF,iBAArB,EAAwCnF,GAAC,EAAzC,EAA+C;AAE9C,gBAAKA,GAAC,GAAG,CAAJ,KAAU,CAAf,EAAmB;AAElB6D,cAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAYjB,GAAZ,CAAjB;AACA6D,cAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAYjB,GAAC,GAAG,CAAhB,CAAjB;AACA6D,cAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAYjB,GAAC,GAAG,CAAhB,CAAjB;AAEA,aAND,MAMO;AAEN6D,cAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAYjB,GAAC,GAAG,CAAhB,CAAjB;AACA6D,cAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAYjB,GAAC,GAAG,CAAhB,CAAjB;AACA6D,cAAAA,UAAU,CAACtD,IAAX,CAAiBlB,KAAK,CAAC4B,IAAN,CAAYjB,GAAZ,CAAjB;AAEA;AAED;AAED;;AAED,YAAO6D,UAAU,CAAC5D,MAAX,GAAoB,CAAtB,KAA8BkF,iBAAnC,EAAuD;AAEtDnG,UAAAA,OAAO,CAACmB,KAAR,CAAe,kGAAf;AAEA,SA7E4E,CA+E7E;;;AAEA,YAAMiF,WAAW,GAAGtG,QAAQ,CAAC+F,KAAT,EAApB;AACAO,QAAAA,WAAW,CAAClE,QAAZ,CAAsB2C,UAAtB;AACAuB,QAAAA,WAAW,CAACC,WAAZ;AAEA,eAAOD,WAAP;AAEA,OAvFD,MAuFO;AAENpG,QAAAA,OAAO,CAACmB,KAAR,CAAe,qEAAf,EAAsF+E,QAAtF;AACA,eAAOpG,QAAP;AAEA;AAED;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,kCAAiCwG,MAAjC,EAA0C;AAEzC,UAAKA,MAAM,CAACxG,QAAP,CAAgByG,gBAAhB,KAAqC,IAA1C,EAAiD;AAEhDvG,QAAAA,OAAO,CAACmB,KAAR,CAAe,oEAAf;AACA,eAAO,IAAP;AAEA;;AAED,UAAMqF,GAAG,GAAG,IAAI5G,OAAJ,EAAZ;;AACA,UAAM6G,GAAG,GAAG,IAAI7G,OAAJ,EAAZ;;AACA,UAAM8G,GAAG,GAAG,IAAI9G,OAAJ,EAAZ;;AAEA,UAAM+G,MAAM,GAAG,IAAI/G,OAAJ,EAAf;;AACA,UAAMgH,MAAM,GAAG,IAAIhH,OAAJ,EAAf;;AACA,UAAMiH,MAAM,GAAG,IAAIjH,OAAJ,EAAf;;AAEA,UAAMkH,OAAO,GAAG,IAAIlH,OAAJ,EAAhB;;AACA,UAAMmH,OAAO,GAAG,IAAInH,OAAJ,EAAhB;;AACA,UAAMoH,OAAO,GAAG,IAAIpH,OAAJ,EAAhB;;AAEA,eAASqH,8BAAT,CACCX,MADD,EAECY,QAFD,EAGCrE,SAHD,EAICoD,cAJD,EAKCpF,oBALD,EAMCsG,CAND,EAOCC,CAPD,EAQC3D,CARD,EASC4D,sBATD,EAUE;AAEDb,QAAAA,GAAG,CAACc,mBAAJ,CAAyBzE,SAAzB,EAAoCsE,CAApC;;AACAV,QAAAA,GAAG,CAACa,mBAAJ,CAAyBzE,SAAzB,EAAoCuE,CAApC;;AACAV,QAAAA,GAAG,CAACY,mBAAJ,CAAyBzE,SAAzB,EAAoCY,CAApC;;AAEA,YAAM8D,eAAe,GAAGjB,MAAM,CAACkB,qBAA/B;;AAEA,YAAKN,QAAQ,CAACO,YAAT,IAAyBxB,cAAzB,IAA2CsB,eAAhD,EAAkE;AAEjET,UAAAA,OAAO,CAAC7D,GAAR,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB;;AACA8D,UAAAA,OAAO,CAAC9D,GAAR,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB;;AACA+D,UAAAA,OAAO,CAAC/D,GAAR,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB;;AAEA,eAAM,IAAIjC,GAAC,GAAG,CAAR,EAAW0G,GAAE,GAAGzB,cAAc,CAAChF,MAArC,EAA6CD,GAAC,GAAG0G,GAAjD,EAAqD1G,GAAC,EAAtD,EAA4D;AAE3D,gBAAM2G,SAAS,GAAGJ,eAAe,CAAEvG,GAAF,CAAjC;AACA,gBAAM4G,KAAK,GAAG3B,cAAc,CAAEjF,GAAF,CAA5B;AAEA,gBAAK2G,SAAS,KAAK,CAAnB,EAAuB;;AAEvBhB,YAAAA,MAAM,CAACW,mBAAP,CAA4BM,KAA5B,EAAmCT,CAAnC;;AACAP,YAAAA,MAAM,CAACU,mBAAP,CAA4BM,KAA5B,EAAmCR,CAAnC;;AACAP,YAAAA,MAAM,CAACS,mBAAP,CAA4BM,KAA5B,EAAmCnE,CAAnC;;AAEA,gBAAK5C,oBAAL,EAA4B;AAE3BiG,cAAAA,OAAO,CAACe,eAAR,CAAyBlB,MAAzB,EAAiCgB,SAAjC;;AACAZ,cAAAA,OAAO,CAACc,eAAR,CAAyBjB,MAAzB,EAAiCe,SAAjC;;AACAX,cAAAA,OAAO,CAACa,eAAR,CAAyBhB,MAAzB,EAAiCc,SAAjC;AAEA,aAND,MAMO;AAENb,cAAAA,OAAO,CAACe,eAAR,CAAyBlB,MAAM,CAACmB,GAAP,CAAYtB,GAAZ,CAAzB,EAA4CmB,SAA5C;;AACAZ,cAAAA,OAAO,CAACc,eAAR,CAAyBjB,MAAM,CAACkB,GAAP,CAAYrB,GAAZ,CAAzB,EAA4CkB,SAA5C;;AACAX,cAAAA,OAAO,CAACa,eAAR,CAAyBhB,MAAM,CAACiB,GAAP,CAAYpB,GAAZ,CAAzB,EAA4CiB,SAA5C;AAEA;AAED;;AAEDnB,UAAAA,GAAG,CAACuB,GAAJ,CAASjB,OAAT;;AACAL,UAAAA,GAAG,CAACsB,GAAJ,CAAShB,OAAT;;AACAL,UAAAA,GAAG,CAACqB,GAAJ,CAASf,OAAT;AAEA;;AAED,YAAKV,MAAM,CAAC0B,aAAZ,EAA4B;AAE3B1B,UAAAA,MAAM,CAAC2B,aAAP,CAAsBd,CAAtB,EAAyBX,GAAzB;AACAF,UAAAA,MAAM,CAAC2B,aAAP,CAAsBb,CAAtB,EAAyBX,GAAzB;AACAH,UAAAA,MAAM,CAAC2B,aAAP,CAAsBxE,CAAtB,EAAyBiD,GAAzB;AAEA;;AAEDW,QAAAA,sBAAsB,CAAEF,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCX,GAAG,CAAC0B,CAA1C;AACAb,QAAAA,sBAAsB,CAAEF,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCX,GAAG,CAAC2B,CAA1C;AACAd,QAAAA,sBAAsB,CAAEF,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCX,GAAG,CAAC4B,CAA1C;AACAf,QAAAA,sBAAsB,CAAED,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCX,GAAG,CAACyB,CAA1C;AACAb,QAAAA,sBAAsB,CAAED,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCX,GAAG,CAAC0B,CAA1C;AACAd,QAAAA,sBAAsB,CAAED,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCX,GAAG,CAAC2B,CAA1C;AACAf,QAAAA,sBAAsB,CAAE5D,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCiD,GAAG,CAACwB,CAA1C;AACAb,QAAAA,sBAAsB,CAAE5D,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCiD,GAAG,CAACyB,CAA1C;AACAd,QAAAA,sBAAsB,CAAE5D,CAAC,GAAG,CAAJ,GAAQ,CAAV,CAAtB,GAAsCiD,GAAG,CAAC0B,CAA1C;AAEA;;AAED,UAAMtI,QAAQ,GAAGwG,MAAM,CAACxG,QAAxB;AACA,UAAMoH,QAAQ,GAAGZ,MAAM,CAACY,QAAxB;AAEA,UAAIC,CAAJ,EAAOC,CAAP,EAAU3D,CAAV;AACA,UAAMpD,KAAK,GAAGP,QAAQ,CAACO,KAAvB;AACA,UAAMgI,iBAAiB,GAAGvI,QAAQ,CAACY,UAAT,CAAoBkB,QAA9C;AACA,UAAM0G,aAAa,GAAGxI,QAAQ,CAACc,eAAT,CAAyBgB,QAA/C;AACA,UAAMf,oBAAoB,GAAGf,QAAQ,CAACe,oBAAtC;AACA,UAAM0H,eAAe,GAAGzI,QAAQ,CAACY,UAAT,CAAoB8H,MAA5C;AACA,UAAMC,WAAW,GAAG3I,QAAQ,CAACc,eAAT,CAAyBgB,QAA7C;AAEA,UAAM8G,MAAM,GAAG5I,QAAQ,CAAC4I,MAAxB;AACA,UAAMC,SAAS,GAAG7I,QAAQ,CAAC6I,SAA3B;AACA,UAAI3H,CAAJ,EAAOgB,CAAP,EAAU0F,EAAV,EAAckB,EAAd;AACA,UAAIC,KAAJ,EAAWC,aAAX;AACA,UAAIC,KAAJ,EAAWC,GAAX;AAEA,UAAMC,gBAAgB,GAAG,IAAIC,YAAJ,CAAkBb,iBAAiB,CAAC1G,KAAlB,GAA0B0G,iBAAiB,CAAC3F,QAA9D,CAAzB;AACA,UAAMyG,cAAc,GAAG,IAAID,YAAJ,CAAkBX,eAAe,CAAC5G,KAAhB,GAAwB4G,eAAe,CAAC7F,QAA1D,CAAvB;;AAEA,UAAKrC,KAAK,KAAK,IAAf,EAAsB;AAErB;AAEA,YAAK0E,KAAK,CAACqE,OAAN,CAAelC,QAAf,CAAL,EAAiC;AAEhC,eAAMlG,CAAC,GAAG,CAAJ,EAAO0G,EAAE,GAAGgB,MAAM,CAACzH,MAAzB,EAAiCD,CAAC,GAAG0G,EAArC,EAAyC1G,CAAC,EAA1C,EAAgD;AAE/C6H,YAAAA,KAAK,GAAGH,MAAM,CAAE1H,CAAF,CAAd;AACA8H,YAAAA,aAAa,GAAG5B,QAAQ,CAAE2B,KAAK,CAACQ,aAAR,CAAxB;AAEAN,YAAAA,KAAK,GAAG7E,IAAI,CAACC,GAAL,CAAU0E,KAAK,CAACE,KAAhB,EAAuBJ,SAAS,CAACI,KAAjC,CAAR;AACAC,YAAAA,GAAG,GAAG9E,IAAI,CAACoF,GAAL,CAAYT,KAAK,CAACE,KAAN,GAAcF,KAAK,CAAClH,KAAhC,EAA2CgH,SAAS,CAACI,KAAV,GAAkBJ,SAAS,CAAChH,KAAvE,CAAN;;AAEA,iBAAMK,CAAC,GAAG+G,KAAJ,EAAWH,EAAE,GAAGI,GAAtB,EAA2BhH,CAAC,GAAG4G,EAA/B,EAAmC5G,CAAC,IAAI,CAAxC,EAA4C;AAE3CmF,cAAAA,CAAC,GAAG9G,KAAK,CAAC4B,IAAN,CAAYD,CAAZ,CAAJ;AACAoF,cAAAA,CAAC,GAAG/G,KAAK,CAAC4B,IAAN,CAAYD,CAAC,GAAG,CAAhB,CAAJ;AACAyB,cAAAA,CAAC,GAAGpD,KAAK,CAAC4B,IAAN,CAAYD,CAAC,GAAG,CAAhB,CAAJ;;AAEAiF,cAAAA,8BAA8B,CAC7BX,MAD6B,EAE7BwC,aAF6B,EAG7BT,iBAH6B,EAI7BC,aAJ6B,EAK7BzH,oBAL6B,EAM7BsG,CAN6B,EAM1BC,CAN0B,EAMvB3D,CANuB,EAO7BwF,gBAP6B,CAA9B;;AAUAhC,cAAAA,8BAA8B,CAC7BX,MAD6B,EAE7BwC,aAF6B,EAG7BP,eAH6B,EAI7BE,WAJ6B,EAK7B5H,oBAL6B,EAM7BsG,CAN6B,EAM1BC,CAN0B,EAMvB3D,CANuB,EAO7B0F,cAP6B,CAA9B;AAUA;AAED;AAED,SAxCD,MAwCO;AAENJ,UAAAA,KAAK,GAAG7E,IAAI,CAACC,GAAL,CAAU,CAAV,EAAawE,SAAS,CAACI,KAAvB,CAAR;AACAC,UAAAA,GAAG,GAAG9E,IAAI,CAACoF,GAAL,CAAUjJ,KAAK,CAACsB,KAAhB,EAAyBgH,SAAS,CAACI,KAAV,GAAkBJ,SAAS,CAAChH,KAArD,CAAN;;AAEA,eAAMX,CAAC,GAAG+H,KAAJ,EAAWrB,EAAE,GAAGsB,GAAtB,EAA2BhI,CAAC,GAAG0G,EAA/B,EAAmC1G,CAAC,IAAI,CAAxC,EAA4C;AAE3CmG,YAAAA,CAAC,GAAG9G,KAAK,CAAC4B,IAAN,CAAYjB,CAAZ,CAAJ;AACAoG,YAAAA,CAAC,GAAG/G,KAAK,CAAC4B,IAAN,CAAYjB,CAAC,GAAG,CAAhB,CAAJ;AACAyC,YAAAA,CAAC,GAAGpD,KAAK,CAAC4B,IAAN,CAAYjB,CAAC,GAAG,CAAhB,CAAJ;;AAEAiG,YAAAA,8BAA8B,CAC7BX,MAD6B,EAE7BY,QAF6B,EAG7BmB,iBAH6B,EAI7BC,aAJ6B,EAK7BzH,oBAL6B,EAM7BsG,CAN6B,EAM1BC,CAN0B,EAMvB3D,CANuB,EAO7BwF,gBAP6B,CAA9B;;AAUAhC,YAAAA,8BAA8B,CAC7BX,MAD6B,EAE7BY,QAF6B,EAG7BqB,eAH6B,EAI7BE,WAJ6B,EAK7B5H,oBAL6B,EAM7BsG,CAN6B,EAM1BC,CAN0B,EAMvB3D,CANuB,EAO7B0F,cAP6B,CAA9B;AAUA;AAED;AAED,OA/ED,MA+EO,IAAKd,iBAAiB,KAAK/G,SAA3B,EAAuC;AAE7C;AAEA,YAAKyD,KAAK,CAACqE,OAAN,CAAelC,QAAf,CAAL,EAAiC;AAEhC,eAAMlG,CAAC,GAAG,CAAJ,EAAO0G,EAAE,GAAGgB,MAAM,CAACzH,MAAzB,EAAiCD,CAAC,GAAG0G,EAArC,EAAyC1G,CAAC,EAA1C,EAAgD;AAE/C6H,YAAAA,KAAK,GAAGH,MAAM,CAAE1H,CAAF,CAAd;AACA8H,YAAAA,aAAa,GAAG5B,QAAQ,CAAE2B,KAAK,CAACQ,aAAR,CAAxB;AAEAN,YAAAA,KAAK,GAAG7E,IAAI,CAACC,GAAL,CAAU0E,KAAK,CAACE,KAAhB,EAAuBJ,SAAS,CAACI,KAAjC,CAAR;AACAC,YAAAA,GAAG,GAAG9E,IAAI,CAACoF,GAAL,CAAYT,KAAK,CAACE,KAAN,GAAcF,KAAK,CAAClH,KAAhC,EAA2CgH,SAAS,CAACI,KAAV,GAAkBJ,SAAS,CAAChH,KAAvE,CAAN;;AAEA,iBAAMK,CAAC,GAAG+G,KAAJ,EAAWH,EAAE,GAAGI,GAAtB,EAA2BhH,CAAC,GAAG4G,EAA/B,EAAmC5G,CAAC,IAAI,CAAxC,EAA4C;AAE3CmF,cAAAA,CAAC,GAAGnF,CAAJ;AACAoF,cAAAA,CAAC,GAAGpF,CAAC,GAAG,CAAR;AACAyB,cAAAA,CAAC,GAAGzB,CAAC,GAAG,CAAR;;AAEAiF,cAAAA,8BAA8B,CAC7BX,MAD6B,EAE7BwC,aAF6B,EAG7BT,iBAH6B,EAI7BC,aAJ6B,EAK7BzH,oBAL6B,EAM7BsG,CAN6B,EAM1BC,CAN0B,EAMvB3D,CANuB,EAO7BwF,gBAP6B,CAA9B;;AAUAhC,cAAAA,8BAA8B,CAC7BX,MAD6B,EAE7BwC,aAF6B,EAG7BP,eAH6B,EAI7BE,WAJ6B,EAK7B5H,oBAL6B,EAM7BsG,CAN6B,EAM1BC,CAN0B,EAMvB3D,CANuB,EAO7B0F,cAP6B,CAA9B;AAUA;AAED;AAED,SAxCD,MAwCO;AAENJ,UAAAA,KAAK,GAAG7E,IAAI,CAACC,GAAL,CAAU,CAAV,EAAawE,SAAS,CAACI,KAAvB,CAAR;AACAC,UAAAA,GAAG,GAAG9E,IAAI,CAACoF,GAAL,CAAUjB,iBAAiB,CAAC1G,KAA5B,EAAqCgH,SAAS,CAACI,KAAV,GAAkBJ,SAAS,CAAChH,KAAjE,CAAN;;AAEA,eAAMX,CAAC,GAAG+H,KAAJ,EAAWrB,EAAE,GAAGsB,GAAtB,EAA2BhI,CAAC,GAAG0G,EAA/B,EAAmC1G,CAAC,IAAI,CAAxC,EAA4C;AAE3CmG,YAAAA,CAAC,GAAGnG,CAAJ;AACAoG,YAAAA,CAAC,GAAGpG,CAAC,GAAG,CAAR;AACAyC,YAAAA,CAAC,GAAGzC,CAAC,GAAG,CAAR;;AAEAiG,YAAAA,8BAA8B,CAC7BX,MAD6B,EAE7BY,QAF6B,EAG7BmB,iBAH6B,EAI7BC,aAJ6B,EAK7BzH,oBAL6B,EAM7BsG,CAN6B,EAM1BC,CAN0B,EAMvB3D,CANuB,EAO7BwF,gBAP6B,CAA9B;;AAUAhC,YAAAA,8BAA8B,CAC7BX,MAD6B,EAE7BY,QAF6B,EAG7BqB,eAH6B,EAI7BE,WAJ6B,EAK7B5H,oBAL6B,EAM7BsG,CAN6B,EAM1BC,CAN0B,EAMvB3D,CANuB,EAO7B0F,cAP6B,CAA9B;AAUA;AAED;AAED;;AAED,UAAMI,wBAAwB,GAAG,IAAIjK,sBAAJ,CAA4B2J,gBAA5B,EAA8C,CAA9C,CAAjC;AACA,UAAMO,sBAAsB,GAAG,IAAIlK,sBAAJ,CAA4B6J,cAA5B,EAA4C,CAA5C,CAA/B;AAEA,aAAO;AAENd,QAAAA,iBAAiB,EAAEA,iBAFb;AAGNE,QAAAA,eAAe,EAAEA,eAHX;AAINgB,QAAAA,wBAAwB,EAAEA,wBAJpB;AAKNC,QAAAA,sBAAsB,EAAEA;AALlB,OAAP;AASA;;;;;;AAIF,SAAS3J,mBAAT","sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3\n} from 'three';\n\nclass BufferGeometryUtils {\n\n\tstatic computeTangents( geometry ) {\n\n\t\tgeometry.computeTangents();\n\t\tconsole.warn( 'THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.' );\n\n\t}\n\n\t/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\n\tstatic mergeBufferGeometries( geometries, useGroups = false ) {\n\n\t\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\t\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\tconst attributes = {};\n\t\tconst morphAttributes = {};\n\n\t\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\tconst mergedGeometry = new BufferGeometry();\n\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst geometry = geometries[ i ];\n\t\t\tlet attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\n\t\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather .userData\n\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tlet count;\n\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\n\t\tif ( isIndexed ) {\n\n\t\t\tlet indexOffset = 0;\n\t\t\tconst mergedIndex = [];\n\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst index = geometries[ i ].index;\n\n\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t}\n\n\t\t// merge attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\tif ( ! mergedAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t}\n\n\t\t// merge morph attributes\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tconst mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mergedGeometry;\n\n\t}\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {BufferAttribute}\n\t */\n\tstatic mergeBufferAttributes( attributes ) {\n\n\t\tlet TypedArray;\n\t\tlet itemSize;\n\t\tlet normalized;\n\t\tlet arrayLength = 0;\n\n\t\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tconst attribute = attributes[ i ];\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\n\t\t}\n\n\t\tconst array = new TypedArray( arrayLength );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\toffset += attributes[ i ].array.length;\n\n\t\t}\n\n\t\treturn new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {Array<InterleavedBufferAttribute>}\n\t */\n\tstatic interleaveAttributes( attributes ) {\n\n\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\tlet TypedArray;\n\t\tlet arrayLength = 0;\n\t\tlet stride = 0;\n\n\t\t// calculate the the length and type of the interleavedBuffer\n\t\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\tconst attribute = attributes[ i ];\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\t\t\tstride += attribute.itemSize;\n\n\t\t}\n\n\t\t// Create the set of buffer attributes\n\t\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\tlet offset = 0;\n\t\tconst res = [];\n\t\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\tconst attribute = attributes[ j ];\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst count = attribute.count;\n\t\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\tres.push( iba );\n\n\t\t\toffset += itemSize;\n\n\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t// at the appropriate offset\n\t\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n\t/**\n\t * @param {Array<BufferGeometry>} geometry\n\t * @return {number}\n\t */\n\tstatic estimateBytesUsed( geometry ) {\n\n\t\t// Return the estimated memory used by this geometry in bytes\n\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t// for InterleavedBufferAttributes.\n\t\tlet mem = 0;\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tconst attr = geometry.getAttribute( name );\n\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t}\n\n\t\tconst indices = geometry.getIndex();\n\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\treturn mem;\n\n\t}\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} tolerance\n\t * @return {BufferGeometry>}\n\t */\n\tstatic mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t// if it's already available.\n\t\tconst hashToIndex = {};\n\t\tconst indices = geometry.getIndex();\n\t\tconst positions = geometry.getAttribute( 'position' );\n\t\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t\t// next value for triangle indices\n\t\tlet nextIndex = 0;\n\n\t\t// attributes and new attribute arrays\n\t\tconst attributeNames = Object.keys( geometry.attributes );\n\t\tconst attrArrays = {};\n\t\tconst morphAttrsArrays = {};\n\t\tconst newIndices = [];\n\t\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t// initialize the arrays\n\t\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tconst name = attributeNames[ i ];\n\n\t\t\tattrArrays[ name ] = [];\n\n\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\tif ( morphAttr ) {\n\n\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\tconst decimalShift = Math.log10( 1 / tolerance );\n\t\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\tlet hash = '';\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add another reference to the vertex if it's already\n\t\t\t// used by another index\n\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t} else {\n\n\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\t\tconst newarray = attrArrays[ name ];\n\t\t\t\t\tconst newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\tnextIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate typed arrays from new attribute arrays and update\n\t\t// the attributeBuffers\n\t\tconst result = geometry.clone();\n\t\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tconst name = attributeNames[ i ];\n\t\t\tconst oldAttribute = geometry.getAttribute( name );\n\n\t\t\tconst buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\tconst attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t// Update the attribute arrays\n\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\tfor ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\tconst oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\tconst buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\tconst morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tresult.setIndex( newIndices );\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} drawMode\n\t * @return {BufferGeometry>}\n\t */\n\tstatic toTrianglesDrawMode( geometry, drawMode ) {\n\n\t\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\t\tlet index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tconst indices = [];\n\n\t\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst numberOfTriangles = index.count - 2;\n\t\t\tconst newIndices = [];\n\n\t\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tconst newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\tnewGeometry.clearGroups();\n\n\t\t\treturn newGeometry;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n\t * Helpful for Raytracing or Decals.\n\t * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n\t * @return {Object} An Object with original position/normal attributes and morphed ones.\n\t */\n\tstatic computeMorphedAttributes( object ) {\n\n\t\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst _vA = new Vector3();\n\t\tconst _vB = new Vector3();\n\t\tconst _vC = new Vector3();\n\n\t\tconst _tempA = new Vector3();\n\t\tconst _tempB = new Vector3();\n\t\tconst _tempC = new Vector3();\n\n\t\tconst _morphA = new Vector3();\n\t\tconst _morphB = new Vector3();\n\t\tconst _morphC = new Vector3();\n\n\t\tfunction _calculateMorphedAttributeData(\n\t\t\tobject,\n\t\t\tmaterial,\n\t\t\tattribute,\n\t\t\tmorphAttribute,\n\t\t\tmorphTargetsRelative,\n\t\t\ta,\n\t\t\tb,\n\t\t\tc,\n\t\t\tmodifiedAttributeArray\n\t\t) {\n\n\t\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_vA.add( _morphA );\n\t\t\t\t_vB.add( _morphB );\n\t\t\t\t_vC.add( _morphC );\n\n\t\t\t}\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tobject.boneTransform( a, _vA );\n\t\t\t\tobject.boneTransform( b, _vB );\n\t\t\t\tobject.boneTransform( c, _vC );\n\n\t\t\t}\n\n\t\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t\t}\n\n\t\tconst geometry = object.geometry;\n\t\tconst material = object.material;\n\n\t\tlet a, b, c;\n\t\tconst index = geometry.index;\n\t\tconst positionAttribute = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst normalAttribute = geometry.attributes.normal;\n\t\tconst morphNormal = geometry.morphAttributes.position;\n\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\t\tlet i, j, il, jl;\n\t\tlet group, groupMaterial;\n\t\tlet start, end;\n\n\t\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\t\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\ta = index.getX( i );\n\t\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( positionAttribute !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\ta = j;\n\t\t\t\t\t\tb = j + 1;\n\t\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\ta = i;\n\t\t\t\t\tb = i + 1;\n\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\t\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\t\treturn {\n\n\t\t\tpositionAttribute: positionAttribute,\n\t\t\tnormalAttribute: normalAttribute,\n\t\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t\t};\n\n\t}\n\n}\n\nexport { BufferGeometryUtils };\n"]},"metadata":{},"sourceType":"module"}