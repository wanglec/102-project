{"ast":null,"code":"import { Delaunay } from \"d3-delaunay\";\nimport { scaleLinear } from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\nexport default function () {\n  // accessors\n  let x = d => d[0],\n      y = d => d[1],\n      value = d => isFinite(+d[2]) ? +d[2] : 0,\n      triangulate = Delaunay.from,\n      pointInterpolate = (i, j, a) => {\n    const {\n      points\n    } = triangulation;\n    const A = [points[2 * i], points[2 * i + 1]],\n          B = [points[2 * j], points[2 * j + 1]];\n    return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n  },\n      ringsort = planarRingsort;\n\n  let thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear().domain(extent(values)).nice().ticks(thresholds);\n    }\n  }\n\n  function* tricontours(points) {\n    init(points);\n\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n\n  function contour(points, threshold) {\n    init(points);\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function* isobands(points) {\n    init(points);\n    let p0, p1, th0;\n\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(p0.concat(p1.map(ring => ring.slice().reverse()))),\n          value: th0,\n          valueMax: th\n        };\n      }\n\n      th0 = th;\n    }\n  }\n\n  const contours = function (data) {\n    return [...tricontours(data)];\n  }; // API\n\n\n  contours.x = _ => _ ? (x = _, contours) : x;\n\n  contours.y = _ => _ ? (y = _, contours) : y;\n\n  contours.value = _ => _ ? (value = _, contours) : value;\n\n  contours.thresholds = _ => _ ? (thresholds = _, contours) : thresholds;\n\n  contours.triangulate = _ => _ ? (triangulate = _, contours) : triangulate;\n\n  contours.pointInterpolate = _ => _ ? (pointInterpolate = _, contours) : pointInterpolate;\n\n  contours.ringsort = _ => _ ? (ringsort = _, contours) : ringsort;\n\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands; // expose the internals (useful for debugging, not part of the API)\n\n  contours._values = () => values;\n\n  contours._thresholds = () => thresholds;\n\n  contours._triangulation = () => triangulation;\n\n  return contours; // navigate a triangle\n\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values, v0 = 0) {\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n\n    const {\n      halfedges,\n      hull,\n      inedges,\n      triangles\n    } = triangulation,\n          n = values.length;\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n\n    function alpha(i, j) {\n      const u = values[i],\n            v = values[j];\n\n      if ((u - v0) * (v - v0) <= 0 && u - v) {\n        return (v0 - u) / Math.abs(u - v);\n      }\n    } // create the path from the first exit; cancel visited halfedges\n\n\n    const rings = [],\n          visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[j = next(i)]]; // is our tour done?\n\n        if (path.length && ti === path[0].ti && tj === path[0].tj || path.length > 2 * n) break;\n        visited[i] = 1;\n        path.push({\n          ti,\n          tj,\n          a\n        }); // jump into the adjacent triangle\n\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          } // debugger;\n\n        } // or follow the hull\n        else {\n            let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n\n            while (values[hull[h]] < v0) {\n              // debugger;\n              h = (h + 1) % hull.length;\n            }\n\n            while (values[hull[h]] >= v0) {\n              path.push({\n                ti: hull[h],\n                tj: hull[h],\n                a: 0\n              });\n              h = (h + 1) % hull.length;\n            } // take that entry\n\n\n            j = inedges[hull[h]];\n            path.push({\n              ti: hull[h],\n              tj: triangles[j],\n              a: alpha(hull[h], triangles[j])\n            });\n            if (edgealpha(i = next(j)) > 0) continue;\n            if (edgealpha(i = prev(j)) > 0) continue;\n          }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(({\n          ti,\n          tj,\n          a\n        }) => pointInterpolate(ti, tj, a)));\n      }\n    } // special case all values on the hull are >=v0, add the hull\n\n\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(Array.from(hull).concat([hull[0]]).map(i => pointInterpolate(i, i, 0)));\n    }\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}","map":{"version":3,"sources":["/Users/lechuanwang/node_modules/d3-tricontour/src/tricontour.js"],"names":["Delaunay","scaleLinear","extent","merge","planarRingsort","x","d","y","value","isFinite","triangulate","from","pointInterpolate","i","j","a","points","triangulation","A","B","ringsort","thresholds","values","init","Array","domain","nice","ticks","tricontours","threshold","polygon","tricontour","type","coordinates","contour","isobands","p0","p1","th0","th","concat","map","ring","slice","reverse","valueMax","contours","data","_","_values","_thresholds","_triangulation","next","prev","v0","halfedges","hull","inedges","triangles","n","length","edgealpha","alpha","u","v","Math","abs","rings","visited","Uint8Array","fill","path","k","ti","tj","push","h","indexOf","every","unshift"],"mappings":"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","sourcesContent":["import {Delaunay} from \"d3-delaunay\";\nimport {scaleLinear} from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\n\nexport default function() {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => (isFinite(+d[2]) ? +d[2] : 0),\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const { points } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n\n  let thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear()\n        .domain(extent(values))\n        .nice()\n        .ticks(thresholds);\n    }\n  }\n\n  function* tricontours(points) {\n    init(points);\n\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n\n  function contour(points, threshold) {\n    init(points);\n\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function* isobands(points) {\n    init(points);\n\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(\n            p0.concat(p1.map(ring => ring.slice().reverse()))\n          ),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n\n  const contours = function(data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => (_ ? ((x = _), contours) : x);\n  contours.y = _ => (_ ? ((y = _), contours) : y);\n  contours.value = _ => (_ ? ((value = _), contours) : value);\n  contours.thresholds = _ => (_ ? ((thresholds = _), contours) : thresholds);\n  contours.triangulate = _ => (_ ? ((triangulate = _), contours) : triangulate);\n  contours.pointInterpolate = _ =>\n    _ ? ((pointInterpolate = _), contours) : pointInterpolate;\n  contours.ringsort = _ =>\n    _ ? ((ringsort = _), contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._thresholds = () => thresholds;\n  contours._triangulation = () => triangulation;\n\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values, v0 = 0) {\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n\n    const { halfedges, hull, inedges, triangles } = triangulation,\n      n = values.length;\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if ((u - v0) * (v - v0) <= 0 && u - v) {\n        return (v0 - u) / Math.abs(u - v);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[(j = next(i))]];\n\n        // is our tour done?\n        if (\n          (path.length && (ti === path[0].ti && tj === path[0].tj)) ||\n          path.length > 2 * n\n        )\n          break;\n\n        visited[i] = 1;\n        path.push({ ti, tj, a });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n\n          while (values[hull[h]] >= v0) {\n            path.push({ ti: hull[h], tj: hull[h], a: 0 });\n            h = (h + 1) % hull.length;\n          }\n\n          // take that entry\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n\n          if (edgealpha((i = next(j))) > 0) continue;\n          if (edgealpha((i = prev(j))) > 0) continue;\n        }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(({ ti, tj, a }) => pointInterpolate(ti, tj, a)));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(\n        Array.from(hull)\n          .concat([hull[0]])\n          .map(i => pointInterpolate(i, i, 0))\n      );\n    }\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}"]},"metadata":{},"sourceType":"module"}