{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, mean } from 'd3-array';\nimport earcut from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$resolution = _ref.resolution,\n      resolution = _ref$resolution === void 0 ? Infinity : _ref$resolution;\n\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds = geoBounds(boundariesGeojson),\n      _geoBounds2 = _slicedToArray(_geoBounds, 2),\n      _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n      minLng = _geoBounds2$[0],\n      minLat = _geoBounds2$[1],\n      _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n      maxLng = _geoBounds2$2[0],\n      maxLat = _geoBounds2$2[1];\n\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          lng = _ref3[0],\n          lat = _ref3[1];\n\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            lng = _ref5[0],\n            lat = _ref5[1];\n\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n      // exclude edge triangles outside polygon perimeter or through holes\n\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcut$flatten = earcut.flatten(contour),\n        vertices = _earcut$flatten.vertices,\n        _earcut$flatten$holes = _earcut$flatten.holes,\n        holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n\n    indices = earcut(vertices, holes, 2);\n  } else {\n    (function () {\n      // use delaunator\n      var delaunay = Delaunator.from(points);\n\n      var _loop = function _loop(i, len) {\n        var _indices2;\n\n        var inds = [2, 1, 0].map(function (idx) {\n          return delaunay.triangles[i + idx];\n        }); // reverse wound to have same orientation as earcut\n\n        var triangle = inds.map(function (indice) {\n          return points[indice];\n        }); // exclude edge triangles outside polygon perimeter or through holes\n\n        if (inds.some(function (ind) {\n          return ind < edgePoints.length;\n        })) {\n          var triangleCentroid = [0, 1].map(function (coordIdx) {\n            return mean(triangle, function (p) {\n              return p[coordIdx];\n            });\n          });\n          if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return \"continue\";\n        }\n\n        (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n      };\n\n      for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    })();\n  }\n\n  var triangles = {\n    points: points,\n    indices: indices\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\n\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\n\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n      _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n      _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n      minLng = _geoBounds4$[0],\n      minLat = _geoBounds4$[1],\n      _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n      maxLng = _geoBounds4$2[0],\n      maxLat = _geoBounds4$2[1]; // polygon smaller than maxDistance -> no inner points\n\n\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\n\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      minLng = _ref6.minLng,\n      maxLng = _ref6.maxLng,\n      minLat = _ref6.minLat,\n      maxLat = _ref6.maxLat;\n\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI); // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n\n  return pnts;\n}\n\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nfunction ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n  var _this = this;\n\n  THREE.BufferGeometry.call(this);\n  this.type = 'ConicPolygonBufferGeometry';\n  this.parameters = {\n    polygonGeoJson: polygonGeoJson,\n    startHeight: startHeight,\n    endHeight: endHeight,\n    closedBottom: closedBottom,\n    closedTop: closedTop,\n    includeSides: includeSides,\n    curvatureResolution: curvatureResolution\n  }; // defaults\n\n  startHeight = startHeight || 0;\n  endHeight = endHeight || 1;\n  closedBottom = closedBottom !== undefined ? closedBottom : true;\n  closedTop = closedTop !== undefined ? closedTop : true;\n  includeSides = includeSides !== undefined ? includeSides : true;\n  curvatureResolution = curvatureResolution || 5; // in angular degrees\n  // pre-calculate contour and triangulation\n\n  var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n    resolution: curvatureResolution\n  }),\n      contour = _geoPolygonTriangulat.contour,\n      triangles = _geoPolygonTriangulat.triangles;\n\n  var vertices = [];\n  var indices = [];\n  var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n  var addGroup = function addGroup(groupData) {\n    var prevVertCnt = Math.round(vertices.length / 3);\n    var prevIndCnt = indices.length;\n    vertices = vertices.concat(groupData.vertices);\n    indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n      return ind + prevVertCnt;\n    }));\n\n    _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n  };\n\n  includeSides && addGroup(generateTorso());\n  closedBottom && addGroup(generateCap(startHeight, false));\n  closedTop && addGroup(generateCap(endHeight, true)); // build geometry\n\n  this.setIndex(indices);\n  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); // auto-calculate normals\n\n  this.computeFaceNormals();\n  this.computeVertexNormals(); //\n\n  function generateVertices(polygon, altitude) {\n    var coords3d = polygon.map(function (coords) {\n      return coords.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            lng = _ref2[0],\n            lat = _ref2[1];\n\n        return polar2Cartesian(lat, lng, altitude);\n      });\n    }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n\n    return earcut.flatten(coords3d);\n  }\n\n  function generateTorso() {\n    var _generateVertices = generateVertices(contour, startHeight),\n        bottomVerts = _generateVertices.vertices,\n        holes = _generateVertices.holes;\n\n    var _generateVertices2 = generateVertices(contour, endHeight),\n        topVerts = _generateVertices2.vertices;\n\n    var vertices = merge([topVerts, bottomVerts]);\n    var numPoints = Math.round(topVerts.length / 3);\n    var holesIdx = new Set(holes);\n    var lastHoleIdx = 0;\n    var indices = [];\n\n    for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n      var v1Idx = v0Idx + 1; // next point\n\n      if (v1Idx === numPoints) {\n        v1Idx = lastHoleIdx; // close final loop\n      } else if (holesIdx.has(v1Idx)) {\n        var holeIdx = v1Idx;\n        v1Idx = lastHoleIdx; // close hole loop\n\n        lastHoleIdx = holeIdx;\n      } // Each pair of coords generates two triangles (faces)\n\n\n      indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n      indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n    }\n\n    return {\n      indices: indices,\n      vertices: vertices\n    };\n  }\n\n  function generateCap(radius) {\n    var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return {\n      // need to reverse-wind the bottom triangles to make them face outwards\n      indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n      vertices: generateVertices([triangles.points], radius).vertices\n    };\n  }\n}\n\nConicPolygonBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nConicPolygonBufferGeometry.prototype.constructor = ConicPolygonBufferGeometry; //\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonBufferGeometry as ConicPolygonGeometry };","map":{"version":3,"sources":["/Users/lechuanwang/node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.module.js"],"names":["BufferGeometry","Float32BufferAttribute","merge","mean","earcut","Delaunator","turfPointInPolygon","geoBounds","geoContains","geoDistance","geoInterpolate","geoVoronoi","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Symbol","iterator","Object","from","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","o","minLen","n","prototype","toString","call","slice","constructor","name","test","len","arr2","TypeError","geoPolygonTriangulate","polygon","_ref","arguments","_ref$resolution","resolution","Infinity","contour","interpolateContourPoints","edgePoints","innerPoints","getInnerGeoPoints","points","concat","boundariesGeojson","type","coordinates","_geoBounds","_geoBounds2","_geoBounds2$","minLng","minLat","_geoBounds2$2","maxLng","maxLat","crossesPoleOrAntimeridian","indices","vt","triangles","pntMap","Map","map","_ref2","idx","_ref3","lng","lat","features","forEach","f","_indices","triangle","geometry","reverse","inds","_ref4","_ref5","k","has","get","some","ind","triangleCentroid","properties","circumcenter","pointInside","apply","_earcut$flatten","flatten","vertices","_earcut$flatten$holes","holes","delaunay","_loop","_indices2","indice","coordIdx","p","_ret","maxDistance","coords","pnts","prevPnt","pnt","dist","Math","PI","interpol","tStep","ceil","t","_geoBounds3","_geoBounds4","_geoBounds4$","_geoBounds4$2","min","abs","getGeoSpiralGrid","filter","distanceBetweenPoints","_ref6","numPoints","round","pow","phi","sqrt","getPntLng","getPntLat","acos","getPntIdx","cos","pntIdxRange","floor","isLngInRange","THREE","window","setAttributeFn","setAttribute","ConicPolygonBufferGeometry","polygonGeoJson","startHeight","endHeight","closedBottom","closedTop","includeSides","curvatureResolution","_this","parameters","_geoPolygonTriangulat","groupCnt","addGroup","groupData","prevVertCnt","prevIndCnt","generateTorso","generateCap","setIndex","computeFaceNormals","computeVertexNormals","generateVertices","altitude","coords3d","polar2Cartesian","_generateVertices","bottomVerts","_generateVertices2","topVerts","holesIdx","Set","lastHoleIdx","v0Idx","v1Idx","holeIdx","radius","isTop","create","r","theta","sin","ConicPolygonGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, mean } from 'd3-array';\nimport earcut from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$resolution = _ref.resolution,\n      resolution = _ref$resolution === void 0 ? Infinity : _ref$resolution;\n\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds = geoBounds(boundariesGeojson),\n      _geoBounds2 = _slicedToArray(_geoBounds, 2),\n      _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n      minLng = _geoBounds2$[0],\n      minLat = _geoBounds2$[1],\n      _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n      maxLng = _geoBounds2$2[0],\n      maxLat = _geoBounds2$2[1];\n\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          lng = _ref3[0],\n          lat = _ref3[1];\n\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            lng = _ref5[0],\n            lat = _ref5[1];\n\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n      // exclude edge triangles outside polygon perimeter or through holes\n\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcut$flatten = earcut.flatten(contour),\n        vertices = _earcut$flatten.vertices,\n        _earcut$flatten$holes = _earcut$flatten.holes,\n        holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n\n    indices = earcut(vertices, holes, 2);\n  } else {\n    (function () {\n      // use delaunator\n      var delaunay = Delaunator.from(points);\n\n      var _loop = function _loop(i, len) {\n        var _indices2;\n\n        var inds = [2, 1, 0].map(function (idx) {\n          return delaunay.triangles[i + idx];\n        }); // reverse wound to have same orientation as earcut\n\n        var triangle = inds.map(function (indice) {\n          return points[indice];\n        }); // exclude edge triangles outside polygon perimeter or through holes\n\n        if (inds.some(function (ind) {\n          return ind < edgePoints.length;\n        })) {\n          var triangleCentroid = [0, 1].map(function (coordIdx) {\n            return mean(triangle, function (p) {\n              return p[coordIdx];\n            });\n          });\n          if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return \"continue\";\n        }\n\n        (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n      };\n\n      for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    })();\n  }\n\n  var triangles = {\n    points: points,\n    indices: indices\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\n\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\n\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n      _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n      _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n      minLng = _geoBounds4$[0],\n      minLat = _geoBounds4$[1],\n      _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n      maxLng = _geoBounds4$2[0],\n      maxLat = _geoBounds4$2[1]; // polygon smaller than maxDistance -> no inner points\n\n\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\n\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      minLng = _ref6.minLng,\n      maxLng = _ref6.maxLng,\n      minLat = _ref6.minLat,\n      maxLat = _ref6.maxLat;\n\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI); // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n\n  return pnts;\n}\n\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nfunction ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n  var _this = this;\n\n  THREE.BufferGeometry.call(this);\n  this.type = 'ConicPolygonBufferGeometry';\n  this.parameters = {\n    polygonGeoJson: polygonGeoJson,\n    startHeight: startHeight,\n    endHeight: endHeight,\n    closedBottom: closedBottom,\n    closedTop: closedTop,\n    includeSides: includeSides,\n    curvatureResolution: curvatureResolution\n  }; // defaults\n\n  startHeight = startHeight || 0;\n  endHeight = endHeight || 1;\n  closedBottom = closedBottom !== undefined ? closedBottom : true;\n  closedTop = closedTop !== undefined ? closedTop : true;\n  includeSides = includeSides !== undefined ? includeSides : true;\n  curvatureResolution = curvatureResolution || 5; // in angular degrees\n  // pre-calculate contour and triangulation\n\n  var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n    resolution: curvatureResolution\n  }),\n      contour = _geoPolygonTriangulat.contour,\n      triangles = _geoPolygonTriangulat.triangles;\n\n  var vertices = [];\n  var indices = [];\n  var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n  var addGroup = function addGroup(groupData) {\n    var prevVertCnt = Math.round(vertices.length / 3);\n    var prevIndCnt = indices.length;\n    vertices = vertices.concat(groupData.vertices);\n    indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n      return ind + prevVertCnt;\n    }));\n\n    _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n  };\n\n  includeSides && addGroup(generateTorso());\n  closedBottom && addGroup(generateCap(startHeight, false));\n  closedTop && addGroup(generateCap(endHeight, true)); // build geometry\n\n  this.setIndex(indices);\n  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); // auto-calculate normals\n\n  this.computeFaceNormals();\n  this.computeVertexNormals(); //\n\n  function generateVertices(polygon, altitude) {\n    var coords3d = polygon.map(function (coords) {\n      return coords.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            lng = _ref2[0],\n            lat = _ref2[1];\n\n        return polar2Cartesian(lat, lng, altitude);\n      });\n    }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n\n    return earcut.flatten(coords3d);\n  }\n\n  function generateTorso() {\n    var _generateVertices = generateVertices(contour, startHeight),\n        bottomVerts = _generateVertices.vertices,\n        holes = _generateVertices.holes;\n\n    var _generateVertices2 = generateVertices(contour, endHeight),\n        topVerts = _generateVertices2.vertices;\n\n    var vertices = merge([topVerts, bottomVerts]);\n    var numPoints = Math.round(topVerts.length / 3);\n    var holesIdx = new Set(holes);\n    var lastHoleIdx = 0;\n    var indices = [];\n\n    for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n      var v1Idx = v0Idx + 1; // next point\n\n      if (v1Idx === numPoints) {\n        v1Idx = lastHoleIdx; // close final loop\n      } else if (holesIdx.has(v1Idx)) {\n        var holeIdx = v1Idx;\n        v1Idx = lastHoleIdx; // close hole loop\n\n        lastHoleIdx = holeIdx;\n      } // Each pair of coords generates two triangles (faces)\n\n\n      indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n      indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n    }\n\n    return {\n      indices: indices,\n      vertices: vertices\n    };\n  }\n\n  function generateCap(radius) {\n    var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return {\n      // need to reverse-wind the bottom triangles to make them face outwards\n      indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n      vertices: generateVertices([triangles.points], radius).vertices\n    };\n  }\n}\n\nConicPolygonBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nConicPolygonBufferGeometry.prototype.constructor = ConicPolygonBufferGeometry; //\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonBufferGeometry as ConicPolygonGeometry };\n"]},"metadata":{},"sourceType":"module"}