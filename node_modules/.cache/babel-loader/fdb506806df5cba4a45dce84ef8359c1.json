{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, mean } from 'd3-array';\nimport earcut from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$resolution = _ref.resolution,\n      resolution = _ref$resolution === void 0 ? Infinity : _ref$resolution;\n\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds = geoBounds(boundariesGeojson),\n      _geoBounds2 = _slicedToArray(_geoBounds, 2),\n      _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n      minLng = _geoBounds2$[0],\n      minLat = _geoBounds2$[1],\n      _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n      maxLng = _geoBounds2$2[0],\n      maxLat = _geoBounds2$2[1];\n\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          lng = _ref3[0],\n          lat = _ref3[1];\n\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            lng = _ref5[0],\n            lat = _ref5[1];\n\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n      // exclude edge triangles outside polygon perimeter or through holes\n\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcut$flatten = earcut.flatten(contour),\n        vertices = _earcut$flatten.vertices,\n        _earcut$flatten$holes = _earcut$flatten.holes,\n        holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n\n    indices = earcut(vertices, holes, 2);\n  } else {\n    (function () {\n      // use delaunator\n      var delaunay = Delaunator.from(points);\n\n      var _loop = function _loop(i, len) {\n        var _indices2;\n\n        var inds = [2, 1, 0].map(function (idx) {\n          return delaunay.triangles[i + idx];\n        }); // reverse wound to have same orientation as earcut\n\n        var triangle = inds.map(function (indice) {\n          return points[indice];\n        }); // exclude edge triangles outside polygon perimeter or through holes\n\n        if (inds.some(function (ind) {\n          return ind < edgePoints.length;\n        })) {\n          var triangleCentroid = [0, 1].map(function (coordIdx) {\n            return mean(triangle, function (p) {\n              return p[coordIdx];\n            });\n          });\n          if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return \"continue\";\n        }\n\n        (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n      };\n\n      for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    })();\n  }\n\n  var triangles = {\n    points: points,\n    indices: indices\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\n\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\n\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n      _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n      _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n      minLng = _geoBounds4$[0],\n      minLat = _geoBounds4$[1],\n      _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n      maxLng = _geoBounds4$2[0],\n      maxLat = _geoBounds4$2[1]; // polygon smaller than maxDistance -> no inner points\n\n\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\n\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      minLng = _ref6.minLng,\n      maxLng = _ref6.maxLng,\n      minLat = _ref6.minLat,\n      maxLat = _ref6.maxLat;\n\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI); // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n\n  return pnts;\n}\n\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar ConicPolygonBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(ConicPolygonBufferGeometry, _THREE$BufferGeometry);\n\n  var _super = _createSuper(ConicPolygonBufferGeometry);\n\n  function ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n    var _this;\n\n    _classCallCheck(this, ConicPolygonBufferGeometry);\n\n    _this = _super.call(this);\n    _this.type = 'ConicPolygonBufferGeometry';\n    _this.parameters = {\n      polygonGeoJson: polygonGeoJson,\n      startHeight: startHeight,\n      endHeight: endHeight,\n      closedBottom: closedBottom,\n      closedTop: closedTop,\n      includeSides: includeSides,\n      curvatureResolution: curvatureResolution\n    }; // defaults\n\n    startHeight = startHeight || 0;\n    endHeight = endHeight || 1;\n    closedBottom = closedBottom !== undefined ? closedBottom : true;\n    closedTop = closedTop !== undefined ? closedTop : true;\n    includeSides = includeSides !== undefined ? includeSides : true;\n    curvatureResolution = curvatureResolution || 5; // in angular degrees\n    // pre-calculate contour and triangulation\n\n    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n      resolution: curvatureResolution\n    }),\n        contour = _geoPolygonTriangulat.contour,\n        triangles = _geoPolygonTriangulat.triangles;\n\n    var vertices = [];\n    var indices = [];\n    var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n    var addGroup = function addGroup(groupData) {\n      var prevVertCnt = Math.round(vertices.length / 3);\n      var prevIndCnt = indices.length;\n      vertices = vertices.concat(groupData.vertices);\n      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n        return ind + prevVertCnt;\n      }));\n\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    };\n\n    includeSides && addGroup(generateTorso());\n    closedBottom && addGroup(generateCap(startHeight, false));\n    closedTop && addGroup(generateCap(endHeight, true)); // build geometry\n\n    _this.setIndex(indices);\n\n    _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); // auto-calculate normals\n\n\n    _this.computeFaceNormals();\n\n    _this.computeVertexNormals(); //\n\n\n    function generateVertices(polygon, altitude) {\n      var coords3d = polygon.map(function (coords) {\n        return coords.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              lng = _ref2[0],\n              lat = _ref2[1];\n\n          return polar2Cartesian(lat, lng, altitude);\n        });\n      }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n\n      return earcut.flatten(coords3d);\n    }\n\n    function generateTorso() {\n      var _generateVertices = generateVertices(contour, startHeight),\n          bottomVerts = _generateVertices.vertices,\n          holes = _generateVertices.holes;\n\n      var _generateVertices2 = generateVertices(contour, endHeight),\n          topVerts = _generateVertices2.vertices;\n\n      var vertices = merge([topVerts, bottomVerts]);\n      var numPoints = Math.round(topVerts.length / 3);\n      var holesIdx = new Set(holes);\n      var lastHoleIdx = 0;\n      var indices = [];\n\n      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n        var v1Idx = v0Idx + 1; // next point\n\n        if (v1Idx === numPoints) {\n          v1Idx = lastHoleIdx; // close final loop\n        } else if (holesIdx.has(v1Idx)) {\n          var holeIdx = v1Idx;\n          v1Idx = lastHoleIdx; // close hole loop\n\n          lastHoleIdx = holeIdx;\n        } // Each pair of coords generates two triangles (faces)\n\n\n        indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n        indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n      }\n\n      return {\n        indices: indices,\n        vertices: vertices\n      };\n    }\n\n    function generateCap(radius) {\n      var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return {\n        // need to reverse-wind the bottom triangles to make them face outwards\n        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n        vertices: generateVertices([triangles.points], radius).vertices\n      };\n    }\n\n    return _this;\n  }\n\n  return ConicPolygonBufferGeometry;\n}(THREE.BufferGeometry); //\n\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonBufferGeometry as ConicPolygonGeometry };","map":{"version":3,"sources":["/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.module.js"],"names":["BufferGeometry","Float32BufferAttribute","merge","mean","earcut","Delaunator","turfPointInPolygon","geoBounds","geoContains","geoDistance","geoInterpolate","geoVoronoi","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","writable","configurable","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","call","e","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","arguments","apply","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Symbol","iterator","from","_i","_arr","_n","_d","_s","_e","next","done","push","length","err","minLen","n","toString","slice","name","test","len","arr2","geoPolygonTriangulate","polygon","_ref","undefined","_ref$resolution","resolution","Infinity","contour","interpolateContourPoints","edgePoints","innerPoints","getInnerGeoPoints","points","concat","boundariesGeojson","type","coordinates","_geoBounds","_geoBounds2","_geoBounds2$","minLng","minLat","_geoBounds2$2","maxLng","maxLat","crossesPoleOrAntimeridian","indices","vt","triangles","pntMap","Map","map","_ref2","idx","_ref3","lng","lat","features","forEach","f","_indices","triangle","geometry","reverse","inds","_ref4","_ref5","k","has","get","some","ind","triangleCentroid","properties","circumcenter","pointInside","_earcut$flatten","flatten","vertices","_earcut$flatten$holes","holes","delaunay","_loop","_indices2","indice","coordIdx","_ret","maxDistance","coords","pnts","prevPnt","pnt","dist","Math","PI","interpol","tStep","ceil","t","_geoBounds3","_geoBounds4","_geoBounds4$","_geoBounds4$2","min","abs","getGeoSpiralGrid","filter","distanceBetweenPoints","_ref6","numPoints","round","pow","phi","sqrt","getPntLng","getPntLat","acos","getPntIdx","cos","pntIdxRange","floor","isLngInRange","THREE","window","setAttributeFn","setAttribute","ConicPolygonBufferGeometry","_THREE$BufferGeometry","_super","polygonGeoJson","startHeight","endHeight","closedBottom","closedTop","includeSides","curvatureResolution","_this","parameters","_geoPolygonTriangulat","groupCnt","addGroup","groupData","prevVertCnt","prevIndCnt","generateTorso","generateCap","setIndex","computeFaceNormals","computeVertexNormals","generateVertices","altitude","coords3d","polar2Cartesian","_generateVertices","bottomVerts","_generateVertices2","topVerts","holesIdx","Set","lastHoleIdx","v0Idx","v1Idx","holeIdx","radius","isTop","r","theta","sin","ConicPolygonGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, mean } from 'd3-array';\nimport earcut from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$resolution = _ref.resolution,\n      resolution = _ref$resolution === void 0 ? Infinity : _ref$resolution;\n\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds = geoBounds(boundariesGeojson),\n      _geoBounds2 = _slicedToArray(_geoBounds, 2),\n      _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n      minLng = _geoBounds2$[0],\n      minLat = _geoBounds2$[1],\n      _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n      maxLng = _geoBounds2$2[0],\n      maxLat = _geoBounds2$2[1];\n\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          lng = _ref3[0],\n          lat = _ref3[1];\n\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            lng = _ref5[0],\n            lat = _ref5[1];\n\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n      // exclude edge triangles outside polygon perimeter or through holes\n\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcut$flatten = earcut.flatten(contour),\n        vertices = _earcut$flatten.vertices,\n        _earcut$flatten$holes = _earcut$flatten.holes,\n        holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n\n    indices = earcut(vertices, holes, 2);\n  } else {\n    (function () {\n      // use delaunator\n      var delaunay = Delaunator.from(points);\n\n      var _loop = function _loop(i, len) {\n        var _indices2;\n\n        var inds = [2, 1, 0].map(function (idx) {\n          return delaunay.triangles[i + idx];\n        }); // reverse wound to have same orientation as earcut\n\n        var triangle = inds.map(function (indice) {\n          return points[indice];\n        }); // exclude edge triangles outside polygon perimeter or through holes\n\n        if (inds.some(function (ind) {\n          return ind < edgePoints.length;\n        })) {\n          var triangleCentroid = [0, 1].map(function (coordIdx) {\n            return mean(triangle, function (p) {\n              return p[coordIdx];\n            });\n          });\n          if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return \"continue\";\n        }\n\n        (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n      };\n\n      for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    })();\n  }\n\n  var triangles = {\n    points: points,\n    indices: indices\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\n\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\n\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n      _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n      _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n      minLng = _geoBounds4$[0],\n      minLat = _geoBounds4$[1],\n      _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n      maxLng = _geoBounds4$2[0],\n      maxLat = _geoBounds4$2[1]; // polygon smaller than maxDistance -> no inner points\n\n\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\n\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      minLng = _ref6.minLng,\n      maxLng = _ref6.maxLng,\n      minLat = _ref6.minLat,\n      maxLat = _ref6.maxLat;\n\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI); // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n\n  return pnts;\n}\n\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar ConicPolygonBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(ConicPolygonBufferGeometry, _THREE$BufferGeometry);\n\n  var _super = _createSuper(ConicPolygonBufferGeometry);\n\n  function ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n    var _this;\n\n    _classCallCheck(this, ConicPolygonBufferGeometry);\n\n    _this = _super.call(this);\n    _this.type = 'ConicPolygonBufferGeometry';\n    _this.parameters = {\n      polygonGeoJson: polygonGeoJson,\n      startHeight: startHeight,\n      endHeight: endHeight,\n      closedBottom: closedBottom,\n      closedTop: closedTop,\n      includeSides: includeSides,\n      curvatureResolution: curvatureResolution\n    }; // defaults\n\n    startHeight = startHeight || 0;\n    endHeight = endHeight || 1;\n    closedBottom = closedBottom !== undefined ? closedBottom : true;\n    closedTop = closedTop !== undefined ? closedTop : true;\n    includeSides = includeSides !== undefined ? includeSides : true;\n    curvatureResolution = curvatureResolution || 5; // in angular degrees\n    // pre-calculate contour and triangulation\n\n    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n      resolution: curvatureResolution\n    }),\n        contour = _geoPolygonTriangulat.contour,\n        triangles = _geoPolygonTriangulat.triangles;\n\n    var vertices = [];\n    var indices = [];\n    var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n    var addGroup = function addGroup(groupData) {\n      var prevVertCnt = Math.round(vertices.length / 3);\n      var prevIndCnt = indices.length;\n      vertices = vertices.concat(groupData.vertices);\n      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n        return ind + prevVertCnt;\n      }));\n\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    };\n\n    includeSides && addGroup(generateTorso());\n    closedBottom && addGroup(generateCap(startHeight, false));\n    closedTop && addGroup(generateCap(endHeight, true)); // build geometry\n\n    _this.setIndex(indices);\n\n    _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); // auto-calculate normals\n\n\n    _this.computeFaceNormals();\n\n    _this.computeVertexNormals(); //\n\n\n    function generateVertices(polygon, altitude) {\n      var coords3d = polygon.map(function (coords) {\n        return coords.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              lng = _ref2[0],\n              lat = _ref2[1];\n\n          return polar2Cartesian(lat, lng, altitude);\n        });\n      }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n\n      return earcut.flatten(coords3d);\n    }\n\n    function generateTorso() {\n      var _generateVertices = generateVertices(contour, startHeight),\n          bottomVerts = _generateVertices.vertices,\n          holes = _generateVertices.holes;\n\n      var _generateVertices2 = generateVertices(contour, endHeight),\n          topVerts = _generateVertices2.vertices;\n\n      var vertices = merge([topVerts, bottomVerts]);\n      var numPoints = Math.round(topVerts.length / 3);\n      var holesIdx = new Set(holes);\n      var lastHoleIdx = 0;\n      var indices = [];\n\n      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n        var v1Idx = v0Idx + 1; // next point\n\n        if (v1Idx === numPoints) {\n          v1Idx = lastHoleIdx; // close final loop\n        } else if (holesIdx.has(v1Idx)) {\n          var holeIdx = v1Idx;\n          v1Idx = lastHoleIdx; // close hole loop\n\n          lastHoleIdx = holeIdx;\n        } // Each pair of coords generates two triangles (faces)\n\n\n        indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n        indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n      }\n\n      return {\n        indices: indices,\n        vertices: vertices\n      };\n    }\n\n    function generateCap(radius) {\n      var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return {\n        // need to reverse-wind the bottom triangles to make them face outwards\n        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n        vertices: generateVertices([triangles.points], radius).vertices\n      };\n    }\n\n    return _this;\n  }\n\n  return ConicPolygonBufferGeometry;\n}(THREE.BufferGeometry); //\n\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonBufferGeometry as ConicPolygonGeometry };\n"]},"metadata":{},"sourceType":"module"}