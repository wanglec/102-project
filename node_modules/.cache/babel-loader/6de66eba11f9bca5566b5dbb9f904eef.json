{"ast":null,"code":"import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, Vector2, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar LineSegmentsGeometry = function () {\n  THREE.InstancedBufferGeometry.call(this);\n  this.type = 'LineSegmentsGeometry';\n  var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n  var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n  var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n  this.setIndex(index);\n  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(positions, 3));\n  this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2));\n};\n\nLineSegmentsGeometry.prototype = Object.assign(Object.create(THREE.InstancedBufferGeometry.prototype), {\n  constructor: LineSegmentsGeometry,\n  isLineSegmentsGeometry: true,\n  applyMatrix: function (matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  },\n  applyMatrix4: function (matrix) {\n    var start = this.attributes.instanceStart;\n    var end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      matrix.applyToBufferAttribute(start);\n      matrix.applyToBufferAttribute(end);\n      start.data.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  setPositions: function (array) {\n    var lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    var instanceBuffer = new THREE.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn]('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn]('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  },\n  setColors: function (array) {\n    var colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    var instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn]('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn]('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  },\n  fromWireframeGeometry: function (geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromEdgesGeometry: function (geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromMesh: function (mesh) {\n    this.fromWireframeGeometry(new THREE.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  },\n  fromLineSegements: function (lineSegments) {\n    var geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      this.setPositions(geometry.vertices);\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  computeBoundingBox: function () {\n    var box = new THREE.Box3();\n    return function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new THREE.Box3();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        this.boundingBox.setFromBufferAttribute(start);\n        box.setFromBufferAttribute(end);\n        this.boundingBox.union(box);\n      }\n    };\n  }(),\n  computeBoundingSphere: function () {\n    var vector = new THREE.Vector3();\n    return function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new THREE.Sphere();\n      }\n\n      if (this.boundingBox === null) {\n        this.computeBoundingBox();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        var center = this.boundingSphere.center;\n        this.boundingBox.getCenter(center);\n        var maxRadiusSq = 0;\n\n        for (var i = 0, il = start.count; i < il; i++) {\n          vector.fromBufferAttribute(start, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n          vector.fromBufferAttribute(end, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n        }\n\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n        }\n      }\n    };\n  }(),\n  toJSON: function () {// todo\n  },\n  clone: function () {// todo\n  },\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nvar LineMaterial = function (parameters) {\n  THREE$1.ShaderMaterial.call(this, {\n    type: 'LineMaterial',\n    uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n    vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n    fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n    clipping: true // required for clipping support\n\n  });\n  this.dashed = false;\n  Object.defineProperties(this, {\n    color: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.diffuse.value;\n      },\n      set: function (value) {\n        this.uniforms.diffuse.value = value;\n      }\n    },\n    linewidth: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.linewidth.value;\n      },\n      set: function (value) {\n        this.uniforms.linewidth.value = value;\n      }\n    },\n    dashScale: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashScale.value;\n      },\n      set: function (value) {\n        this.uniforms.dashScale.value = value;\n      }\n    },\n    dashSize: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashSize.value;\n      },\n      set: function (value) {\n        this.uniforms.dashSize.value = value;\n      }\n    },\n    dashOffset: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashOffset.value;\n      },\n      set: function (value) {\n        this.uniforms.dashOffset.value = value;\n      }\n    },\n    gapSize: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.gapSize.value;\n      },\n      set: function (value) {\n        this.uniforms.gapSize.value = value;\n      }\n    },\n    opacity: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.opacity.value;\n      },\n      set: function (value) {\n        this.uniforms.opacity.value = value;\n      }\n    },\n    resolution: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.resolution.value;\n      },\n      set: function (value) {\n        this.uniforms.resolution.value.copy(value);\n      }\n    }\n  });\n  this.setValues(parameters);\n};\n\nLineMaterial.prototype = Object.create(THREE$1.ShaderMaterial.prototype);\nLineMaterial.prototype.constructor = LineMaterial;\nLineMaterial.prototype.isLineMaterial = true;\n\nLineMaterial.prototype.copy = function (source) {\n  THREE$1.ShaderMaterial.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.linewidth = source.linewidth;\n  this.resolution = source.resolution; // todo\n\n  return this;\n};\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\n\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Vector3,\n  Vector4\n};\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar LineSegments2 = function (geometry, material) {\n  if (geometry === undefined) geometry = new LineSegmentsGeometry();\n  if (material === undefined) material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n  THREE$2.Mesh.call(this, geometry, material);\n  this.type = 'LineSegments2';\n};\n\nLineSegments2.prototype = Object.assign(Object.create(THREE$2.Mesh.prototype), {\n  constructor: LineSegments2,\n  isLineSegments2: true,\n  computeLineDistances: function () {\n    // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n    var start = new THREE$2.Vector3();\n    var end = new THREE$2.Vector3();\n    return function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.data.count);\n\n      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);\n      }\n\n      var instanceDistanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry[setAttributeFn$1]('instanceDistanceStart', new THREE$2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry[setAttributeFn$1]('instanceDistanceEnd', new THREE$2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    };\n  }(),\n  raycast: function () {\n    var start = new THREE$2.Vector4();\n    var end = new THREE$2.Vector4();\n    var ssOrigin = new THREE$2.Vector4();\n    var ssOrigin3 = new THREE$2.Vector3();\n    var mvMatrix = new THREE$2.Matrix4();\n    var line = new THREE$2.Line3();\n    var closestPoint = new THREE$2.Vector3();\n    return function raycast(raycaster, intersects) {\n      if (raycaster.camera === null) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n      }\n\n      var threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n      var ray = raycaster.ray;\n      var camera = raycaster.camera;\n      var projectionMatrix = camera.projectionMatrix;\n      var geometry = this.geometry;\n      var material = this.material;\n      var resolution = material.resolution;\n      var lineWidth = material.linewidth + threshold;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd; // pick a point 1 unit out along the ray to avoid the ray origin\n      // sitting at the camera origin which will cause \"w\" to be 0 when\n      // applying the projection matrix.\n\n      ray.at(1, ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n      ssOrigin.w = 1;\n      ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n      ssOrigin.applyMatrix4(projectionMatrix);\n      ssOrigin.multiplyScalar(1 / ssOrigin.w); // screen space\n\n      ssOrigin.x *= resolution.x / 2;\n      ssOrigin.y *= resolution.y / 2;\n      ssOrigin.z = 0;\n      ssOrigin3.copy(ssOrigin);\n      var matrixWorld = this.matrixWorld;\n      mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n      for (var i = 0, l = instanceStart.count; i < l; i++) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        start.w = 1;\n        end.w = 1; // camera space\n\n        start.applyMatrix4(mvMatrix);\n        end.applyMatrix4(mvMatrix); // clip space\n\n        start.applyMatrix4(projectionMatrix);\n        end.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n        start.multiplyScalar(1 / start.w);\n        end.multiplyScalar(1 / end.w); // skip the segment if it's outside the camera near and far planes\n\n        var isBehindCameraNear = start.z < -1 && end.z < -1;\n        var isPastCameraFar = start.z > 1 && end.z > 1;\n\n        if (isBehindCameraNear || isPastCameraFar) {\n          continue;\n        } // screen space\n\n\n        start.x *= resolution.x / 2;\n        start.y *= resolution.y / 2;\n        end.x *= resolution.x / 2;\n        end.y *= resolution.y / 2; // create 2d segment\n\n        line.start.copy(start);\n        line.start.z = 0;\n        line.end.copy(end);\n        line.end.z = 0; // get closest point on ray to segment\n\n        var param = line.closestPointToPointParameter(ssOrigin3, true);\n        line.at(param, closestPoint); // check if the intersection point is within clip space\n\n        var zPos = THREE$2.MathUtils.lerp(start.z, end.z, param);\n        var isInClipSpace = zPos >= -1 && zPos <= 1;\n        var isInside = ssOrigin3.distanceTo(closestPoint) < lineWidth * 0.5;\n\n        if (isInClipSpace && isInside) {\n          line.start.fromBufferAttribute(instanceStart, i);\n          line.end.fromBufferAttribute(instanceEnd, i);\n          line.start.applyMatrix4(matrixWorld);\n          line.end.applyMatrix4(matrixWorld);\n          var pointOnLine = new THREE$2.Vector3();\n          var point = new THREE$2.Vector3();\n          ray.distanceSqToSegment(line.start, line.end, point, pointOnLine);\n          intersects.push({\n            point: point,\n            pointOnLine: pointOnLine,\n            distance: ray.origin.distanceTo(point),\n            object: this,\n            face: null,\n            faceIndex: i,\n            uv: null,\n            uv2: null\n          });\n        }\n      }\n    };\n  }()\n});\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nvar LineGeometry = function () {\n  LineSegmentsGeometry.call(this);\n  this.type = 'LineGeometry';\n};\n\nLineGeometry.prototype = Object.assign(Object.create(LineSegmentsGeometry.prototype), {\n  constructor: LineGeometry,\n  isLineGeometry: true,\n  setPositions: function (array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    LineSegmentsGeometry.prototype.setPositions.call(this, points);\n    return this;\n  },\n  setColors: function (array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    LineSegmentsGeometry.prototype.setColors.call(this, colors);\n    return this;\n  },\n  fromLine: function (line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      this.setPositions(geometry.vertices);\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nvar Line2 = function (geometry, material) {\n  LineSegments2.call(this);\n  this.type = 'Line2';\n  this.geometry = geometry !== undefined ? geometry : new LineGeometry();\n  this.material = material !== undefined ? material : new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n};\n\nLine2.prototype = Object.assign(Object.create(LineSegments2.prototype), {\n  constructor: Line2,\n  isLine2: true,\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };","map":{"version":3,"sources":["/Users/lechuanwang/node_modules/three-fatline/dist/three-fatline.module.js"],"names":["Box3","BufferGeometry","Float32BufferAttribute","InstancedBufferGeometry","InstancedInterleavedBuffer","InterleavedBufferAttribute","Sphere","Vector3","WireframeGeometry","Vector2","ShaderLib","ShaderMaterial","UniformsLib","UniformsUtils","Line3","MathUtils","Matrix4","Mesh","Vector4","THREE","window","setAttributeFn","setAttribute","LineSegmentsGeometry","call","type","positions","uvs","index","setIndex","prototype","Object","assign","create","constructor","isLineSegmentsGeometry","applyMatrix","matrix","console","warn","applyMatrix4","start","attributes","instanceStart","end","instanceEnd","undefined","applyToBufferAttribute","data","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","fromLineSegements","isGeometry","vertices","isBufferGeometry","box","setFromBufferAttribute","union","vector","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","error","toJSON","clone","copy","THREE$1","line","linewidth","value","resolution","dashScale","dashSize","dashOffset","gapSize","opacity","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","clipping","dashed","defineProperties","color","enumerable","get","diffuse","set","setValues","isLineMaterial","source","THREE$2","setAttributeFn$1","LineSegments2","material","random","isLineSegments2","computeLineDistances","lineDistances","j","l","distanceTo","instanceDistanceBuffer","raycast","ssOrigin","ssOrigin3","mvMatrix","closestPoint","raycaster","intersects","camera","threshold","params","Line2","ray","projectionMatrix","lineWidth","at","w","matrixWorldInverse","multiplyScalar","x","y","z","matrixWorld","multiplyMatrices","isBehindCameraNear","isPastCameraFar","param","closestPointToPointParameter","zPos","lerp","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","origin","object","face","faceIndex","uv","uv2","LineGeometry","isLineGeometry","length","points","fromLine","isLine2"],"mappings":"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F,EAAAA,QAAQ,EAAEV,OAAO,CAAClF,aAAR,CAAsB6F,KAAtB,CAA4B,CAACX,OAAO,CAACnF,WAAR,CAAoB+F,MAArB,EAA6BZ,OAAO,CAACnF,WAAR,CAAoBgG,GAAjD,EAAsDb,OAAO,CAACnF,WAAR,CAAoBoF,IAA1E,CAA5B,CADgB;AAE1Ba,EAAAA,YAAY,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAlJ4B;AAmJ1BC,EAAAA,cAAc,EAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","sourcesContent":["import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, Vector2, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar LineSegmentsGeometry = function () {\n  THREE.InstancedBufferGeometry.call(this);\n  this.type = 'LineSegmentsGeometry';\n  var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n  var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n  var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n  this.setIndex(index);\n  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(positions, 3));\n  this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2));\n};\n\nLineSegmentsGeometry.prototype = Object.assign(Object.create(THREE.InstancedBufferGeometry.prototype), {\n  constructor: LineSegmentsGeometry,\n  isLineSegmentsGeometry: true,\n  applyMatrix: function (matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  },\n  applyMatrix4: function (matrix) {\n    var start = this.attributes.instanceStart;\n    var end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      matrix.applyToBufferAttribute(start);\n      matrix.applyToBufferAttribute(end);\n      start.data.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  setPositions: function (array) {\n    var lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    var instanceBuffer = new THREE.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn]('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn]('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  },\n  setColors: function (array) {\n    var colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    var instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn]('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn]('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  },\n  fromWireframeGeometry: function (geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromEdgesGeometry: function (geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromMesh: function (mesh) {\n    this.fromWireframeGeometry(new THREE.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  },\n  fromLineSegements: function (lineSegments) {\n    var geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      this.setPositions(geometry.vertices);\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  computeBoundingBox: function () {\n    var box = new THREE.Box3();\n    return function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new THREE.Box3();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        this.boundingBox.setFromBufferAttribute(start);\n        box.setFromBufferAttribute(end);\n        this.boundingBox.union(box);\n      }\n    };\n  }(),\n  computeBoundingSphere: function () {\n    var vector = new THREE.Vector3();\n    return function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new THREE.Sphere();\n      }\n\n      if (this.boundingBox === null) {\n        this.computeBoundingBox();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        var center = this.boundingSphere.center;\n        this.boundingBox.getCenter(center);\n        var maxRadiusSq = 0;\n\n        for (var i = 0, il = start.count; i < il; i++) {\n          vector.fromBufferAttribute(start, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n          vector.fromBufferAttribute(end, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n        }\n\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n        }\n      }\n    };\n  }(),\n  toJSON: function () {// todo\n  },\n  clone: function () {// todo\n  },\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nvar LineMaterial = function (parameters) {\n  THREE$1.ShaderMaterial.call(this, {\n    type: 'LineMaterial',\n    uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n    vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n    fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n    clipping: true // required for clipping support\n\n  });\n  this.dashed = false;\n  Object.defineProperties(this, {\n    color: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.diffuse.value;\n      },\n      set: function (value) {\n        this.uniforms.diffuse.value = value;\n      }\n    },\n    linewidth: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.linewidth.value;\n      },\n      set: function (value) {\n        this.uniforms.linewidth.value = value;\n      }\n    },\n    dashScale: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashScale.value;\n      },\n      set: function (value) {\n        this.uniforms.dashScale.value = value;\n      }\n    },\n    dashSize: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashSize.value;\n      },\n      set: function (value) {\n        this.uniforms.dashSize.value = value;\n      }\n    },\n    dashOffset: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashOffset.value;\n      },\n      set: function (value) {\n        this.uniforms.dashOffset.value = value;\n      }\n    },\n    gapSize: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.gapSize.value;\n      },\n      set: function (value) {\n        this.uniforms.gapSize.value = value;\n      }\n    },\n    opacity: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.opacity.value;\n      },\n      set: function (value) {\n        this.uniforms.opacity.value = value;\n      }\n    },\n    resolution: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.resolution.value;\n      },\n      set: function (value) {\n        this.uniforms.resolution.value.copy(value);\n      }\n    }\n  });\n  this.setValues(parameters);\n};\n\nLineMaterial.prototype = Object.create(THREE$1.ShaderMaterial.prototype);\nLineMaterial.prototype.constructor = LineMaterial;\nLineMaterial.prototype.isLineMaterial = true;\n\nLineMaterial.prototype.copy = function (source) {\n  THREE$1.ShaderMaterial.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.linewidth = source.linewidth;\n  this.resolution = source.resolution; // todo\n\n  return this;\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Vector3,\n  Vector4\n};\n\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar LineSegments2 = function (geometry, material) {\n  if (geometry === undefined) geometry = new LineSegmentsGeometry();\n  if (material === undefined) material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n  THREE$2.Mesh.call(this, geometry, material);\n  this.type = 'LineSegments2';\n};\n\nLineSegments2.prototype = Object.assign(Object.create(THREE$2.Mesh.prototype), {\n  constructor: LineSegments2,\n  isLineSegments2: true,\n  computeLineDistances: function () {\n    // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n    var start = new THREE$2.Vector3();\n    var end = new THREE$2.Vector3();\n    return function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.data.count);\n\n      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);\n      }\n\n      var instanceDistanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry[setAttributeFn$1]('instanceDistanceStart', new THREE$2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry[setAttributeFn$1]('instanceDistanceEnd', new THREE$2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    };\n  }(),\n  raycast: function () {\n    var start = new THREE$2.Vector4();\n    var end = new THREE$2.Vector4();\n    var ssOrigin = new THREE$2.Vector4();\n    var ssOrigin3 = new THREE$2.Vector3();\n    var mvMatrix = new THREE$2.Matrix4();\n    var line = new THREE$2.Line3();\n    var closestPoint = new THREE$2.Vector3();\n    return function raycast(raycaster, intersects) {\n      if (raycaster.camera === null) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n      }\n\n      var threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n      var ray = raycaster.ray;\n      var camera = raycaster.camera;\n      var projectionMatrix = camera.projectionMatrix;\n      var geometry = this.geometry;\n      var material = this.material;\n      var resolution = material.resolution;\n      var lineWidth = material.linewidth + threshold;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd; // pick a point 1 unit out along the ray to avoid the ray origin\n      // sitting at the camera origin which will cause \"w\" to be 0 when\n      // applying the projection matrix.\n\n      ray.at(1, ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n      ssOrigin.w = 1;\n      ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n      ssOrigin.applyMatrix4(projectionMatrix);\n      ssOrigin.multiplyScalar(1 / ssOrigin.w); // screen space\n\n      ssOrigin.x *= resolution.x / 2;\n      ssOrigin.y *= resolution.y / 2;\n      ssOrigin.z = 0;\n      ssOrigin3.copy(ssOrigin);\n      var matrixWorld = this.matrixWorld;\n      mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n      for (var i = 0, l = instanceStart.count; i < l; i++) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        start.w = 1;\n        end.w = 1; // camera space\n\n        start.applyMatrix4(mvMatrix);\n        end.applyMatrix4(mvMatrix); // clip space\n\n        start.applyMatrix4(projectionMatrix);\n        end.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n        start.multiplyScalar(1 / start.w);\n        end.multiplyScalar(1 / end.w); // skip the segment if it's outside the camera near and far planes\n\n        var isBehindCameraNear = start.z < -1 && end.z < -1;\n        var isPastCameraFar = start.z > 1 && end.z > 1;\n\n        if (isBehindCameraNear || isPastCameraFar) {\n          continue;\n        } // screen space\n\n\n        start.x *= resolution.x / 2;\n        start.y *= resolution.y / 2;\n        end.x *= resolution.x / 2;\n        end.y *= resolution.y / 2; // create 2d segment\n\n        line.start.copy(start);\n        line.start.z = 0;\n        line.end.copy(end);\n        line.end.z = 0; // get closest point on ray to segment\n\n        var param = line.closestPointToPointParameter(ssOrigin3, true);\n        line.at(param, closestPoint); // check if the intersection point is within clip space\n\n        var zPos = THREE$2.MathUtils.lerp(start.z, end.z, param);\n        var isInClipSpace = zPos >= -1 && zPos <= 1;\n        var isInside = ssOrigin3.distanceTo(closestPoint) < lineWidth * 0.5;\n\n        if (isInClipSpace && isInside) {\n          line.start.fromBufferAttribute(instanceStart, i);\n          line.end.fromBufferAttribute(instanceEnd, i);\n          line.start.applyMatrix4(matrixWorld);\n          line.end.applyMatrix4(matrixWorld);\n          var pointOnLine = new THREE$2.Vector3();\n          var point = new THREE$2.Vector3();\n          ray.distanceSqToSegment(line.start, line.end, point, pointOnLine);\n          intersects.push({\n            point: point,\n            pointOnLine: pointOnLine,\n            distance: ray.origin.distanceTo(point),\n            object: this,\n            face: null,\n            faceIndex: i,\n            uv: null,\n            uv2: null\n          });\n        }\n      }\n    };\n  }()\n});\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nvar LineGeometry = function () {\n  LineSegmentsGeometry.call(this);\n  this.type = 'LineGeometry';\n};\n\nLineGeometry.prototype = Object.assign(Object.create(LineSegmentsGeometry.prototype), {\n  constructor: LineGeometry,\n  isLineGeometry: true,\n  setPositions: function (array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    LineSegmentsGeometry.prototype.setPositions.call(this, points);\n    return this;\n  },\n  setColors: function (array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    LineSegmentsGeometry.prototype.setColors.call(this, colors);\n    return this;\n  },\n  fromLine: function (line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      this.setPositions(geometry.vertices);\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nvar Line2 = function (geometry, material) {\n  LineSegments2.call(this);\n  this.type = 'Line2';\n  this.geometry = geometry !== undefined ? geometry : new LineGeometry();\n  this.material = material !== undefined ? material : new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n};\n\nLine2.prototype = Object.assign(Object.create(LineSegments2.prototype), {\n  constructor: Line2,\n  isLine2: true,\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };\n"]},"metadata":{},"sourceType":"module"}