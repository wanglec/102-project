{"ast":null,"code":"//\n// (c) 2019 Philippe Riviere\n//\n// https://github.com/Fil/\n//\n// This software is distributed under the terms of the MIT License\nimport { Delaunay } from \"d3-delaunay\";\nimport { geoRotation, geoStereographic } from \"d3-geo\";\nimport { extent } from \"d3-array\";\nimport { asin, atan, atan2, cos, degrees, halfPi, max, min, pi, radians, sign, sin, sqrt, tan } from \"./math.js\";\nimport { cartesianNormalize as normalize, cartesianCross as cross, cartesianDot as dot, cartesianAdd } from \"./cartesian.js\"; // Converts 3D Cartesian to spherical coordinates (degrees).\n\nfunction spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]) * degrees, asin(max(-1, min(1, cartesian[2]))) * degrees];\n} // Converts spherical coordinates (degrees) to 3D Cartesian.\n\n\nfunction cartesian(coordinates) {\n  var lambda = coordinates[0] * radians,\n      phi = coordinates[1] * radians,\n      cosphi = cos(phi);\n  return [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];\n} // Spherical excess of a triangle (in spherical coordinates)\n\n\nexport function excess(triangle) {\n  triangle = triangle.map(p => cartesian(p));\n  return dot(triangle[0], cross(triangle[2], triangle[1]));\n}\nexport function geoDelaunay(points) {\n  const delaunay = geo_delaunay_from(points),\n        triangles = geo_triangles(delaunay),\n        edges = geo_edges(triangles, points),\n        neighbors = geo_neighbors(triangles, points.length),\n        find = geo_find(neighbors, points),\n        // Voronoi ; could take a center function as an argument\n  circumcenters = geo_circumcenters(triangles, points),\n        {\n    polygons,\n    centers\n  } = geo_polygons(circumcenters, triangles, points),\n        mesh = geo_mesh(polygons),\n        hull = geo_hull(triangles, points),\n        // Urquhart ; returns a function that takes a distance array as argument.\n  urquhart = geo_urquhart(edges, triangles);\n  return {\n    delaunay,\n    edges,\n    triangles,\n    centers,\n    neighbors,\n    polygons,\n    mesh,\n    hull,\n    urquhart,\n    find\n  };\n}\n\nfunction geo_find(neighbors, points) {\n  function distance2(a, b) {\n    let x = a[0] - b[0],\n        y = a[1] - b[1],\n        z = a[2] - b[2];\n    return x * x + y * y + z * z;\n  }\n\n  return function find(x, y, next) {\n    if (next === undefined) next = 0;\n    let cell,\n        dist,\n        found = next;\n    const xyz = cartesian([x, y]);\n\n    do {\n      cell = next;\n      next = null;\n      dist = distance2(xyz, cartesian(points[cell]));\n      neighbors[cell].forEach(i => {\n        let ndist = distance2(xyz, cartesian(points[i]));\n\n        if (ndist < dist) {\n          dist = ndist;\n          next = i;\n          found = i;\n          return;\n        }\n      });\n    } while (next !== null);\n\n    return found;\n  };\n}\n\nfunction geo_delaunay_from(points) {\n  if (points.length < 2) return {}; // find a valid point to send to infinity\n\n  let pivot = 0;\n\n  while (isNaN(points[pivot][0] + points[pivot][1]) && pivot++ < points.length) {}\n\n  const r = geoRotation(points[pivot]),\n        projection = geoStereographic().translate([0, 0]).scale(1).rotate(r.invert([180, 0]));\n  points = points.map(projection);\n  const zeros = [];\n  let max2 = 1;\n\n  for (let i = 0, n = points.length; i < n; i++) {\n    let m = points[i][0] ** 2 + points[i][1] ** 2;\n    if (!isFinite(m) || m > 1e32) zeros.push(i);else if (m > max2) max2 = m;\n  }\n\n  const FAR = 1e6 * sqrt(max2);\n  zeros.forEach(i => points[i] = [FAR, 0]); // Add infinite horizon points\n\n  points.push([0, FAR]);\n  points.push([-FAR, 0]);\n  points.push([0, -FAR]);\n  const delaunay = Delaunay.from(points);\n  delaunay.projection = projection; // clean up the triangulation\n\n  const {\n    triangles,\n    halfedges,\n    inedges\n  } = delaunay;\n  const degenerate = [];\n\n  for (let i = 0, l = halfedges.length; i < l; i++) {\n    if (halfedges[i] < 0) {\n      const j = i % 3 == 2 ? i - 2 : i + 1;\n      const k = i % 3 == 0 ? i + 2 : i - 1;\n      const a = halfedges[j];\n      const b = halfedges[k];\n      halfedges[a] = b;\n      halfedges[b] = a;\n      halfedges[j] = halfedges[k] = -1;\n      triangles[i] = triangles[j] = triangles[k] = pivot;\n      inedges[triangles[a]] = a % 3 == 0 ? a + 2 : a - 1;\n      inedges[triangles[b]] = b % 3 == 0 ? b + 2 : b - 1;\n      degenerate.push(Math.min(i, j, k));\n      i += 2 - i % 3;\n    } else if (triangles[i] > points.length - 3 - 1) {\n      triangles[i] = pivot;\n    }\n  } // there should always be 4 degenerate triangles\n  // console.warn(degenerate);\n\n\n  return delaunay;\n}\n\nfunction geo_edges(triangles, points) {\n  const _index = {};\n  if (points.length === 2) return [[0, 1]];\n  triangles.forEach(tri => {\n    if (tri[0] === tri[1]) return;\n    if (excess(tri.map(i => points[i])) < 0) return;\n\n    for (let i = 0, j; i < 3; i++) {\n      j = (i + 1) % 3;\n      _index[extent([tri[i], tri[j]]).join(\"-\")] = true;\n    }\n  });\n  return Object.keys(_index).map(d => d.split(\"-\").map(Number));\n}\n\nfunction geo_triangles(delaunay) {\n  const {\n    triangles\n  } = delaunay;\n  if (!triangles) return [];\n  const geo_triangles = [];\n\n  for (let i = 0, n = triangles.length / 3; i < n; i++) {\n    const a = triangles[3 * i],\n          b = triangles[3 * i + 1],\n          c = triangles[3 * i + 2];\n\n    if (a !== b && b !== c) {\n      geo_triangles.push([a, c, b]);\n    }\n  }\n\n  return geo_triangles;\n}\n\nfunction geo_circumcenters(triangles, points) {\n  // if (!use_centroids) {\n  return triangles.map(tri => {\n    const c = tri.map(i => points[i]).map(cartesian),\n          V = cartesianAdd(cartesianAdd(cross(c[1], c[0]), cross(c[2], c[1])), cross(c[0], c[2]));\n    return spherical(normalize(V));\n  });\n  /*} else {\n    return triangles.map(tri => {\n      return d3.geoCentroid({\n        type: \"MultiPoint\",\n        coordinates: tri.map(i => points[i])\n      });\n    });\n  }*/\n}\n\nfunction geo_neighbors(triangles, npoints) {\n  const neighbors = [];\n  triangles.forEach((tri, i) => {\n    for (let j = 0; j < 3; j++) {\n      const a = tri[j],\n            b = tri[(j + 1) % 3],\n            c = tri[(j + 2) % 3];\n      neighbors[a] = neighbors[a] || [];\n      neighbors[a].push(b);\n    }\n  }); // degenerate cases\n\n  if (triangles.length === 0) {\n    if (npoints === 2) neighbors[0] = [1], neighbors[1] = [0];else if (npoints === 1) neighbors[0] = [];\n  }\n\n  return neighbors;\n}\n\nfunction geo_polygons(circumcenters, triangles, points) {\n  const polygons = [];\n  const centers = circumcenters.slice(); // supplementary centers for degenerate cases like n = 1,2,3\n\n  const supplements = [];\n\n  if (triangles.length === 0) {\n    if (points.length < 2) return {\n      polygons,\n      centers\n    };\n\n    if (points.length === 2) {\n      // two hemispheres\n      const a = cartesian(points[0]),\n            b = cartesian(points[1]),\n            m = normalize(cartesianAdd(a, b)),\n            d = normalize(cross(a, b)),\n            c = cross(m, d);\n      const poly = [m, cross(m, c), cross(cross(m, c), c), cross(cross(cross(m, c), c), c)].map(spherical).map(supplement);\n      return polygons.push(poly), polygons.push(poly.slice().reverse()), {\n        polygons,\n        centers\n      };\n    }\n  }\n\n  triangles.forEach((tri, t) => {\n    for (let j = 0; j < 3; j++) {\n      const a = tri[j],\n            b = tri[(j + 1) % 3],\n            c = tri[(j + 2) % 3];\n      polygons[a] = polygons[a] || [];\n      polygons[a].push([b, c, t, [a, b, c]]);\n    }\n  }); // reorder each polygon\n\n  const reordered = polygons.map(poly => {\n    const p = [poly[0][2]]; // t\n\n    let k = poly[0][1]; // k = c\n\n    for (let i = 1; i < poly.length; i++) {\n      // look for b = k\n      for (let j = 0; j < poly.length; j++) {\n        if (poly[j][0] == k) {\n          k = poly[j][1];\n          p.push(poly[j][2]);\n          break;\n        }\n      }\n    }\n\n    if (p.length > 2) {\n      return p;\n    } else if (p.length == 2) {\n      const R0 = o_midpoint(points[poly[0][3][0]], points[poly[0][3][1]], centers[p[0]]),\n            R1 = o_midpoint(points[poly[0][3][2]], points[poly[0][3][0]], centers[p[0]]);\n      const i0 = supplement(R0),\n            i1 = supplement(R1);\n      return [p[0], i1, p[1], i0];\n    }\n  });\n\n  function supplement(point) {\n    let f = -1;\n    centers.slice(triangles.length, Infinity).forEach((p, i) => {\n      if (p[0] === point[0] && p[1] === point[1]) f = i + triangles.length;\n    });\n    if (f < 0) f = centers.length, centers.push(point);\n    return f;\n  }\n\n  return {\n    polygons: reordered,\n    centers\n  };\n}\n\nfunction o_midpoint(a, b, c) {\n  a = cartesian(a);\n  b = cartesian(b);\n  c = cartesian(c);\n  const s = sign(dot(cross(b, a), c));\n  return spherical(normalize(cartesianAdd(a, b)).map(d => s * d));\n}\n\nfunction geo_mesh(polygons) {\n  const mesh = [];\n  polygons.forEach(poly => {\n    if (!poly) return;\n    let p = poly[poly.length - 1];\n\n    for (let q of poly) {\n      if (q > p) mesh.push([p, q]);\n      p = q;\n    }\n  });\n  return mesh;\n}\n\nfunction geo_urquhart(edges, triangles) {\n  return function (distances) {\n    const _lengths = {},\n          _urquhart = {};\n    edges.forEach((edge, i) => {\n      const u = edge.join(\"-\");\n      _lengths[u] = distances[i];\n      _urquhart[u] = true;\n    });\n    triangles.forEach(tri => {\n      let l = 0,\n          remove = -1;\n\n      for (var j = 0; j < 3; j++) {\n        let u = extent([tri[j], tri[(j + 1) % 3]]).join(\"-\");\n\n        if (_lengths[u] > l) {\n          l = _lengths[u];\n          remove = u;\n        }\n      }\n\n      _urquhart[remove] = false;\n    });\n    return edges.map(edge => _urquhart[edge.join(\"-\")]);\n  };\n}\n\nfunction geo_hull(triangles, points) {\n  const _hull = {},\n        hull = [];\n  triangles.map(tri => {\n    if (excess(tri.map(i => points[i > points.length ? 0 : i])) < 0) return;\n\n    for (let i = 0; i < 3; i++) {\n      let e = [tri[i], tri[(i + 1) % 3]],\n          code = `${e[1]}-${e[0]}`;\n      if (_hull[code]) delete _hull[code];else _hull[e.join(\"-\")] = true;\n    }\n  });\n  const _index = {};\n  let start;\n  Object.keys(_hull).forEach(e => {\n    e = e.split(\"-\").map(Number);\n    _index[e[0]] = e[1];\n    start = e[0];\n  });\n  if (start === undefined) return hull;\n  let next = start;\n\n  do {\n    hull.push(next);\n    let n = _index[next];\n    _index[next] = -1;\n    next = n;\n  } while (next > -1 && next !== start);\n\n  return hull;\n}","map":{"version":3,"sources":["/Users/lechuanwang/node_modules/d3-geo-voronoi/src/delaunay.js"],"names":["Delaunay","geoRotation","geoStereographic","extent","asin","atan","atan2","cos","degrees","halfPi","max","min","pi","radians","sign","sin","sqrt","tan","cartesianNormalize","normalize","cartesianCross","cross","cartesianDot","dot","cartesianAdd","spherical","cartesian","coordinates","lambda","phi","cosphi","excess","triangle","map","p","geoDelaunay","points","delaunay","geo_delaunay_from","triangles","geo_triangles","edges","geo_edges","neighbors","geo_neighbors","length","find","geo_find","circumcenters","geo_circumcenters","polygons","centers","geo_polygons","mesh","geo_mesh","hull","geo_hull","urquhart","geo_urquhart","distance2","a","b","x","y","z","next","undefined","cell","dist","found","xyz","forEach","i","ndist","pivot","isNaN","r","projection","translate","scale","rotate","invert","zeros","max2","n","m","isFinite","push","FAR","from","halfedges","inedges","degenerate","l","j","k","Math","_index","tri","join","Object","keys","d","split","Number","c","V","npoints","slice","supplements","poly","supplement","reverse","t","reordered","R0","o_midpoint","R1","i0","i1","point","f","Infinity","s","q","distances","_lengths","_urquhart","edge","u","remove","_hull","e","code","start"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,QAAT,QAAyB,aAAzB;AACA,SAASC,WAAT,EAAsBC,gBAAtB,QAA8C,QAA9C;AACA,SAASC,MAAT,QAAuB,UAAvB;AACA,SACEC,IADF,EAEEC,IAFF,EAGEC,KAHF,EAIEC,GAJF,EAKEC,OALF,EAMEC,MANF,EAOEC,GAPF,EAQEC,GARF,EASEC,EATF,EAUEC,OAVF,EAWEC,IAXF,EAYEC,GAZF,EAaEC,IAbF,EAcEC,GAdF,QAeO,WAfP;AAgBA,SACEC,kBAAkB,IAAIC,SADxB,EAEEC,cAAc,IAAIC,KAFpB,EAGEC,YAAY,IAAIC,GAHlB,EAIEC,YAJF,QAKO,gBALP,C,CAOA;;AACA,SAASC,SAAT,CAAmBC,SAAnB,EAA8B;AAC5B,SAAO,CACLpB,KAAK,CAACoB,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAAC,CAAD,CAAxB,CAAL,GAAoClB,OAD/B,EAELJ,IAAI,CAACM,GAAG,CAAC,CAAC,CAAF,EAAKC,GAAG,CAAC,CAAD,EAAIe,SAAS,CAAC,CAAD,CAAb,CAAR,CAAJ,CAAJ,GAAsClB,OAFjC,CAAP;AAID,C,CAED;;;AACA,SAASkB,SAAT,CAAmBC,WAAnB,EAAgC;AAC9B,MAAIC,MAAM,GAAGD,WAAW,CAAC,CAAD,CAAX,GAAiBd,OAA9B;AAAA,MACEgB,GAAG,GAAGF,WAAW,CAAC,CAAD,CAAX,GAAiBd,OADzB;AAAA,MAEEiB,MAAM,GAAGvB,GAAG,CAACsB,GAAD,CAFd;AAGA,SAAO,CAACC,MAAM,GAAGvB,GAAG,CAACqB,MAAD,CAAb,EAAuBE,MAAM,GAAGf,GAAG,CAACa,MAAD,CAAnC,EAA6Cb,GAAG,CAACc,GAAD,CAAhD,CAAP;AACD,C,CAED;;;AACA,OAAO,SAASE,MAAT,CAAgBC,QAAhB,EAA0B;AAC/BA,EAAAA,QAAQ,GAAGA,QAAQ,CAACC,GAAT,CAAaC,CAAC,IAAIR,SAAS,CAACQ,CAAD,CAA3B,CAAX;AACA,SAAOX,GAAG,CAACS,QAAQ,CAAC,CAAD,CAAT,EAAcX,KAAK,CAACW,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAAnB,CAAV;AACD;AAED,OAAO,SAASG,WAAT,CAAqBC,MAArB,EAA6B;AAClC,QAAMC,QAAQ,GAAGC,iBAAiB,CAACF,MAAD,CAAlC;AAAA,QACEG,SAAS,GAAGC,aAAa,CAACH,QAAD,CAD3B;AAAA,QAEEI,KAAK,GAAGC,SAAS,CAACH,SAAD,EAAYH,MAAZ,CAFnB;AAAA,QAGEO,SAAS,GAAGC,aAAa,CAACL,SAAD,EAAYH,MAAM,CAACS,MAAnB,CAH3B;AAAA,QAIEC,IAAI,GAAGC,QAAQ,CAACJ,SAAD,EAAYP,MAAZ,CAJjB;AAAA,QAKE;AACAY,EAAAA,aAAa,GAAGC,iBAAiB,CAACV,SAAD,EAAYH,MAAZ,CANnC;AAAA,QAOE;AAAEc,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,MAAwBC,YAAY,CAACJ,aAAD,EAAgBT,SAAhB,EAA2BH,MAA3B,CAPtC;AAAA,QAQEiB,IAAI,GAAGC,QAAQ,CAACJ,QAAD,CARjB;AAAA,QASEK,IAAI,GAAGC,QAAQ,CAACjB,SAAD,EAAYH,MAAZ,CATjB;AAAA,QAUE;AACAqB,EAAAA,QAAQ,GAAGC,YAAY,CAACjB,KAAD,EAAQF,SAAR,CAXzB;AAYA,SAAO;AACLF,IAAAA,QADK;AAELI,IAAAA,KAFK;AAGLF,IAAAA,SAHK;AAILY,IAAAA,OAJK;AAKLR,IAAAA,SALK;AAMLO,IAAAA,QANK;AAOLG,IAAAA,IAPK;AAQLE,IAAAA,IARK;AASLE,IAAAA,QATK;AAULX,IAAAA;AAVK,GAAP;AAYD;;AAED,SAASC,QAAT,CAAkBJ,SAAlB,EAA6BP,MAA7B,EAAqC;AACnC,WAASuB,SAAT,CAAmBC,CAAnB,EAAqBC,CAArB,EAAwB;AACtB,QAAIC,CAAC,GAAGF,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAhB;AAAA,QACIE,CAAC,GAAGH,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CADhB;AAAA,QAEIG,CAAC,GAAGJ,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAFhB;AAGA,WAAOC,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAZ,GAAgBC,CAAC,GAAGA,CAA3B;AACD;;AAED,SAAO,SAASlB,IAAT,CAAcgB,CAAd,EAAiBC,CAAjB,EAAoBE,IAApB,EAA0B;AAC/B,QAAIA,IAAI,KAAKC,SAAb,EAAwBD,IAAI,GAAG,CAAP;AACxB,QAAIE,IAAJ;AAAA,QACEC,IADF;AAAA,QAEEC,KAAK,GAAGJ,IAFV;AAGA,UAAMK,GAAG,GAAG5C,SAAS,CAAC,CAACoC,CAAD,EAAIC,CAAJ,CAAD,CAArB;;AACA,OAAG;AACDI,MAAAA,IAAI,GAAGF,IAAP;AACAA,MAAAA,IAAI,GAAG,IAAP;AACAG,MAAAA,IAAI,GAAGT,SAAS,CAACW,GAAD,EAAM5C,SAAS,CAACU,MAAM,CAAC+B,IAAD,CAAP,CAAf,CAAhB;AACAxB,MAAAA,SAAS,CAACwB,IAAD,CAAT,CAAgBI,OAAhB,CAAwBC,CAAC,IAAI;AAC3B,YAAIC,KAAK,GAAGd,SAAS,CAACW,GAAD,EAAM5C,SAAS,CAACU,MAAM,CAACoC,CAAD,CAAP,CAAf,CAArB;;AACA,YAAIC,KAAK,GAAGL,IAAZ,EAAkB;AAChBA,UAAAA,IAAI,GAAGK,KAAP;AACAR,UAAAA,IAAI,GAAGO,CAAP;AACAH,UAAAA,KAAK,GAAGG,CAAR;AACA;AACD;AACF,OARD;AASD,KAbD,QAaSP,IAAI,KAAK,IAblB;;AAeA,WAAOI,KAAP;AACD,GAtBD;AAuBD;;AAED,SAAS/B,iBAAT,CAA2BF,MAA3B,EAAmC;AACjC,MAAIA,MAAM,CAACS,MAAP,GAAgB,CAApB,EAAuB,OAAO,EAAP,CADU,CAGjC;;AACA,MAAI6B,KAAK,GAAG,CAAZ;;AACA,SAAOC,KAAK,CAACvC,MAAM,CAACsC,KAAD,CAAN,CAAc,CAAd,IAAiBtC,MAAM,CAACsC,KAAD,CAAN,CAAc,CAAd,CAAlB,CAAL,IAA4CA,KAAK,KAAKtC,MAAM,CAACS,MAApE,EAA4E,CAAE;;AAE9E,QAAM+B,CAAC,GAAG3E,WAAW,CAACmC,MAAM,CAACsC,KAAD,CAAP,CAArB;AAAA,QACEG,UAAU,GAAG3E,gBAAgB,GAC1B4E,SADU,CACA,CAAC,CAAD,EAAI,CAAJ,CADA,EAEVC,KAFU,CAEJ,CAFI,EAGVC,MAHU,CAGHJ,CAAC,CAACK,MAAF,CAAS,CAAC,GAAD,EAAM,CAAN,CAAT,CAHG,CADf;AAKA7C,EAAAA,MAAM,GAAGA,MAAM,CAACH,GAAP,CAAW4C,UAAX,CAAT;AAEA,QAAMK,KAAK,GAAG,EAAd;AACA,MAAIC,IAAI,GAAG,CAAX;;AACA,OAAK,IAAIX,CAAC,GAAG,CAAR,EAAWY,CAAC,GAAGhD,MAAM,CAACS,MAA3B,EAAmC2B,CAAC,GAAGY,CAAvC,EAA0CZ,CAAC,EAA3C,EAA+C;AAC7C,QAAIa,CAAC,GAAGjD,MAAM,CAACoC,CAAD,CAAN,CAAU,CAAV,KAAgB,CAAhB,GAAoBpC,MAAM,CAACoC,CAAD,CAAN,CAAU,CAAV,KAAgB,CAA5C;AACA,QAAI,CAACc,QAAQ,CAACD,CAAD,CAAT,IAAgBA,CAAC,GAAG,IAAxB,EAA8BH,KAAK,CAACK,IAAN,CAAWf,CAAX,EAA9B,KACK,IAAIa,CAAC,GAAGF,IAAR,EAAcA,IAAI,GAAGE,CAAP;AACpB;;AAED,QAAMG,GAAG,GAAG,MAAMxE,IAAI,CAACmE,IAAD,CAAtB;AAEAD,EAAAA,KAAK,CAACX,OAAN,CAAcC,CAAC,IAAKpC,MAAM,CAACoC,CAAD,CAAN,GAAY,CAACgB,GAAD,EAAM,CAAN,CAAhC,EAxBiC,CA0BjC;;AACApD,EAAAA,MAAM,CAACmD,IAAP,CAAY,CAAC,CAAD,EAAGC,GAAH,CAAZ;AACApD,EAAAA,MAAM,CAACmD,IAAP,CAAY,CAAC,CAACC,GAAF,EAAM,CAAN,CAAZ;AACApD,EAAAA,MAAM,CAACmD,IAAP,CAAY,CAAC,CAAD,EAAG,CAACC,GAAJ,CAAZ;AAEA,QAAMnD,QAAQ,GAAGrC,QAAQ,CAACyF,IAAT,CAAcrD,MAAd,CAAjB;AAEAC,EAAAA,QAAQ,CAACwC,UAAT,GAAsBA,UAAtB,CAjCiC,CAmCjC;;AACA,QAAM;AAACtC,IAAAA,SAAD;AAAYmD,IAAAA,SAAZ;AAAuBC,IAAAA;AAAvB,MAAkCtD,QAAxC;AACA,QAAMuD,UAAU,GAAG,EAAnB;;AACA,OAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWqB,CAAC,GAAGH,SAAS,CAAC7C,MAA9B,EAAsC2B,CAAC,GAAGqB,CAA1C,EAA6CrB,CAAC,EAA9C,EAAkD;AAChD,QAAIkB,SAAS,CAAClB,CAAD,CAAT,GAAe,CAAnB,EAAsB;AACpB,YAAMsB,CAAC,GAAGtB,CAAC,GAAG,CAAJ,IAAS,CAAT,GAAaA,CAAC,GAAG,CAAjB,GAAqBA,CAAC,GAAG,CAAnC;AACA,YAAMuB,CAAC,GAAGvB,CAAC,GAAG,CAAJ,IAAS,CAAT,GAAaA,CAAC,GAAG,CAAjB,GAAqBA,CAAC,GAAG,CAAnC;AACA,YAAMZ,CAAC,GAAG8B,SAAS,CAACI,CAAD,CAAnB;AACA,YAAMjC,CAAC,GAAG6B,SAAS,CAACK,CAAD,CAAnB;AACAL,MAAAA,SAAS,CAAC9B,CAAD,CAAT,GAAeC,CAAf;AACA6B,MAAAA,SAAS,CAAC7B,CAAD,CAAT,GAAeD,CAAf;AACA8B,MAAAA,SAAS,CAACI,CAAD,CAAT,GAAeJ,SAAS,CAACK,CAAD,CAAT,GAAe,CAAC,CAA/B;AACAxD,MAAAA,SAAS,CAACiC,CAAD,CAAT,GAAejC,SAAS,CAACuD,CAAD,CAAT,GAAevD,SAAS,CAACwD,CAAD,CAAT,GAAerB,KAA7C;AACAiB,MAAAA,OAAO,CAACpD,SAAS,CAACqB,CAAD,CAAV,CAAP,GAAwBA,CAAC,GAAG,CAAJ,IAAS,CAAT,GAAaA,CAAC,GAAG,CAAjB,GAAqBA,CAAC,GAAG,CAAjD;AACA+B,MAAAA,OAAO,CAACpD,SAAS,CAACsB,CAAD,CAAV,CAAP,GAAwBA,CAAC,GAAG,CAAJ,IAAS,CAAT,GAAaA,CAAC,GAAG,CAAjB,GAAqBA,CAAC,GAAG,CAAjD;AACA+B,MAAAA,UAAU,CAACL,IAAX,CAAgBS,IAAI,CAACrF,GAAL,CAAS6D,CAAT,EAAWsB,CAAX,EAAaC,CAAb,CAAhB;AACAvB,MAAAA,CAAC,IAAI,IAAIA,CAAC,GAAG,CAAb;AACD,KAbD,MAaO,IAAIjC,SAAS,CAACiC,CAAD,CAAT,GAAepC,MAAM,CAACS,MAAP,GAAgB,CAAhB,GAAoB,CAAvC,EAA0C;AAC/CN,MAAAA,SAAS,CAACiC,CAAD,CAAT,GAAeE,KAAf;AACD;AACF,GAvDgC,CAyDjC;AACA;;;AACA,SAAOrC,QAAP;AACD;;AAED,SAASK,SAAT,CAAmBH,SAAnB,EAA8BH,MAA9B,EAAsC;AACpC,QAAM6D,MAAM,GAAG,EAAf;AACA,MAAI7D,MAAM,CAACS,MAAP,KAAkB,CAAtB,EAAyB,OAAO,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,CAAP;AACzBN,EAAAA,SAAS,CAACgC,OAAV,CAAkB2B,GAAG,IAAI;AACvB,QAAIA,GAAG,CAAC,CAAD,CAAH,KAAWA,GAAG,CAAC,CAAD,CAAlB,EAAuB;AACvB,QAAInE,MAAM,CAACmE,GAAG,CAACjE,GAAJ,CAAQuC,CAAC,IAAIpC,MAAM,CAACoC,CAAD,CAAnB,CAAD,CAAN,GAAkC,CAAtC,EAAyC;;AACzC,SAAK,IAAIA,CAAC,GAAG,CAAR,EAAWsB,CAAhB,EAAmBtB,CAAC,GAAG,CAAvB,EAA0BA,CAAC,EAA3B,EAA+B;AAC7BsB,MAAAA,CAAC,GAAG,CAACtB,CAAC,GAAG,CAAL,IAAU,CAAd;AACAyB,MAAAA,MAAM,CAAC9F,MAAM,CAAC,CAAC+F,GAAG,CAAC1B,CAAD,CAAJ,EAAS0B,GAAG,CAACJ,CAAD,CAAZ,CAAD,CAAN,CAAyBK,IAAzB,CAA8B,GAA9B,CAAD,CAAN,GAA6C,IAA7C;AACD;AACF,GAPD;AAQA,SAAOC,MAAM,CAACC,IAAP,CAAYJ,MAAZ,EAAoBhE,GAApB,CAAwBqE,CAAC,IAAIA,CAAC,CAACC,KAAF,CAAQ,GAAR,EAAatE,GAAb,CAAiBuE,MAAjB,CAA7B,CAAP;AACD;;AAED,SAAShE,aAAT,CAAuBH,QAAvB,EAAiC;AAC/B,QAAM;AAACE,IAAAA;AAAD,MAAcF,QAApB;AACA,MAAI,CAACE,SAAL,EAAgB,OAAO,EAAP;AAEhB,QAAMC,aAAa,GAAG,EAAtB;;AACA,OAAK,IAAIgC,CAAC,GAAG,CAAR,EAAWY,CAAC,GAAG7C,SAAS,CAACM,MAAV,GAAmB,CAAvC,EAA0C2B,CAAC,GAAGY,CAA9C,EAAiDZ,CAAC,EAAlD,EAAsD;AACpD,UAAMZ,CAAC,GAAGrB,SAAS,CAAC,IAAIiC,CAAL,CAAnB;AAAA,UACEX,CAAC,GAAGtB,SAAS,CAAC,IAAIiC,CAAJ,GAAQ,CAAT,CADf;AAAA,UAEEiC,CAAC,GAAGlE,SAAS,CAAC,IAAIiC,CAAJ,GAAQ,CAAT,CAFf;;AAGA,QAAIZ,CAAC,KAAKC,CAAN,IAAWA,CAAC,KAAK4C,CAArB,EAAwB;AACtBjE,MAAAA,aAAa,CAAC+C,IAAd,CAAmB,CAAC3B,CAAD,EAAI6C,CAAJ,EAAO5C,CAAP,CAAnB;AACD;AACF;;AACD,SAAOrB,aAAP;AACD;;AAED,SAASS,iBAAT,CAA2BV,SAA3B,EAAsCH,MAAtC,EAA8C;AAC5C;AACA,SAAOG,SAAS,CAACN,GAAV,CAAciE,GAAG,IAAI;AAC1B,UAAMO,CAAC,GAAGP,GAAG,CAACjE,GAAJ,CAAQuC,CAAC,IAAIpC,MAAM,CAACoC,CAAD,CAAnB,EAAwBvC,GAAxB,CAA4BP,SAA5B,CAAV;AAAA,UACEgF,CAAC,GAAGlF,YAAY,CACdA,YAAY,CAACH,KAAK,CAACoF,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,CAAN,EAAoBpF,KAAK,CAACoF,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,CAAzB,CADE,EAEdpF,KAAK,CAACoF,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,CAFS,CADlB;AAKA,WAAOhF,SAAS,CAACN,SAAS,CAACuF,CAAD,CAAV,CAAhB;AACD,GAPM,CAAP;AAQA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACC;;AAED,SAAS9D,aAAT,CAAuBL,SAAvB,EAAkCoE,OAAlC,EAA2C;AACzC,QAAMhE,SAAS,GAAG,EAAlB;AACAJ,EAAAA,SAAS,CAACgC,OAAV,CAAkB,CAAC2B,GAAD,EAAM1B,CAAN,KAAY;AAC5B,SAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAMlC,CAAC,GAAGsC,GAAG,CAACJ,CAAD,CAAb;AAAA,YACEjC,CAAC,GAAGqC,GAAG,CAAC,CAACJ,CAAC,GAAG,CAAL,IAAU,CAAX,CADT;AAAA,YAEEW,CAAC,GAAGP,GAAG,CAAC,CAACJ,CAAC,GAAG,CAAL,IAAU,CAAX,CAFT;AAGAnD,MAAAA,SAAS,CAACiB,CAAD,CAAT,GAAejB,SAAS,CAACiB,CAAD,CAAT,IAAgB,EAA/B;AACAjB,MAAAA,SAAS,CAACiB,CAAD,CAAT,CAAa2B,IAAb,CAAkB1B,CAAlB;AACD;AACF,GARD,EAFyC,CAYzC;;AACA,MAAItB,SAAS,CAACM,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,QAAI8D,OAAO,KAAK,CAAhB,EAAoBhE,SAAS,CAAC,CAAD,CAAT,GAAe,CAAC,CAAD,CAAhB,EAAuBA,SAAS,CAAC,CAAD,CAAT,GAAe,CAAC,CAAD,CAAtC,CAAnB,KACK,IAAIgE,OAAO,KAAK,CAAhB,EAAmBhE,SAAS,CAAC,CAAD,CAAT,GAAe,EAAf;AACzB;;AAED,SAAOA,SAAP;AACD;;AAED,SAASS,YAAT,CAAsBJ,aAAtB,EAAqCT,SAArC,EAAgDH,MAAhD,EAAwD;AACtD,QAAMc,QAAQ,GAAG,EAAjB;AAEA,QAAMC,OAAO,GAAGH,aAAa,CAAC4D,KAAd,EAAhB,CAHsD,CAKtD;;AACA,QAAMC,WAAW,GAAG,EAApB;;AAEA,MAAItE,SAAS,CAACM,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,QAAIT,MAAM,CAACS,MAAP,GAAgB,CAApB,EAAuB,OAAO;AAAEK,MAAAA,QAAF;AAAYC,MAAAA;AAAZ,KAAP;;AACvB,QAAIf,MAAM,CAACS,MAAP,KAAkB,CAAtB,EAAyB;AACvB;AACA,YAAMe,CAAC,GAAGlC,SAAS,CAACU,MAAM,CAAC,CAAD,CAAP,CAAnB;AAAA,YACEyB,CAAC,GAAGnC,SAAS,CAACU,MAAM,CAAC,CAAD,CAAP,CADf;AAAA,YAEEiD,CAAC,GAAGlE,SAAS,CAACK,YAAY,CAACoC,CAAD,EAAIC,CAAJ,CAAb,CAFf;AAAA,YAGEyC,CAAC,GAAGnF,SAAS,CAACE,KAAK,CAACuC,CAAD,EAAIC,CAAJ,CAAN,CAHf;AAAA,YAIE4C,CAAC,GAAGpF,KAAK,CAACgE,CAAD,EAAIiB,CAAJ,CAJX;AAKA,YAAMQ,IAAI,GAAG,CACXzB,CADW,EAEXhE,KAAK,CAACgE,CAAD,EAAIoB,CAAJ,CAFM,EAGXpF,KAAK,CAACA,KAAK,CAACgE,CAAD,EAAIoB,CAAJ,CAAN,EAAcA,CAAd,CAHM,EAIXpF,KAAK,CAACA,KAAK,CAACA,KAAK,CAACgE,CAAD,EAAIoB,CAAJ,CAAN,EAAcA,CAAd,CAAN,EAAwBA,CAAxB,CAJM,EAMVxE,GANU,CAMNR,SANM,EAOVQ,GAPU,CAON8E,UAPM,CAAb;AAQA,aACE7D,QAAQ,CAACqC,IAAT,CAAcuB,IAAd,GACA5D,QAAQ,CAACqC,IAAT,CAAcuB,IAAI,CAACF,KAAL,GAAaI,OAAb,EAAd,CADA,EAEA;AAAE9D,QAAAA,QAAF;AAAYC,QAAAA;AAAZ,OAHF;AAKD;AACF;;AAEDZ,EAAAA,SAAS,CAACgC,OAAV,CAAkB,CAAC2B,GAAD,EAAMe,CAAN,KAAY;AAC5B,SAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAMlC,CAAC,GAAGsC,GAAG,CAACJ,CAAD,CAAb;AAAA,YACEjC,CAAC,GAAGqC,GAAG,CAAC,CAACJ,CAAC,GAAG,CAAL,IAAU,CAAX,CADT;AAAA,YAEEW,CAAC,GAAGP,GAAG,CAAC,CAACJ,CAAC,GAAG,CAAL,IAAU,CAAX,CAFT;AAGA5C,MAAAA,QAAQ,CAACU,CAAD,CAAR,GAAcV,QAAQ,CAACU,CAAD,CAAR,IAAe,EAA7B;AACAV,MAAAA,QAAQ,CAACU,CAAD,CAAR,CAAY2B,IAAZ,CAAiB,CAAC1B,CAAD,EAAI4C,CAAJ,EAAOQ,CAAP,EAAU,CAACrD,CAAD,EAAIC,CAAJ,EAAO4C,CAAP,CAAV,CAAjB;AACD;AACF,GARD,EAjCsD,CA2CtD;;AACA,QAAMS,SAAS,GAAGhE,QAAQ,CAACjB,GAAT,CAAa6E,IAAI,IAAI;AACrC,UAAM5E,CAAC,GAAG,CAAC4E,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAD,CAAV,CADqC,CACb;;AACxB,QAAIf,CAAC,GAAGe,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAR,CAFqC,CAEjB;;AACpB,SAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,IAAI,CAACjE,MAAzB,EAAiC2B,CAAC,EAAlC,EAAsC;AACpC;AACA,WAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgB,IAAI,CAACjE,MAAzB,EAAiCiD,CAAC,EAAlC,EAAsC;AACpC,YAAIgB,IAAI,CAAChB,CAAD,CAAJ,CAAQ,CAAR,KAAcC,CAAlB,EAAqB;AACnBA,UAAAA,CAAC,GAAGe,IAAI,CAAChB,CAAD,CAAJ,CAAQ,CAAR,CAAJ;AACA5D,UAAAA,CAAC,CAACqD,IAAF,CAAOuB,IAAI,CAAChB,CAAD,CAAJ,CAAQ,CAAR,CAAP;AACA;AACD;AACF;AACF;;AAED,QAAI5D,CAAC,CAACW,MAAF,GAAW,CAAf,EAAkB;AAChB,aAAOX,CAAP;AACD,KAFD,MAEO,IAAIA,CAAC,CAACW,MAAF,IAAY,CAAhB,EAAmB;AACxB,YAAMsE,EAAE,GAAGC,UAAU,CACjBhF,MAAM,CAAC0E,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,EAAW,CAAX,CAAD,CADW,EAEjB1E,MAAM,CAAC0E,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,EAAW,CAAX,CAAD,CAFW,EAGjB3D,OAAO,CAACjB,CAAC,CAAC,CAAD,CAAF,CAHU,CAArB;AAAA,YAKEmF,EAAE,GAAGD,UAAU,CACbhF,MAAM,CAAC0E,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,EAAW,CAAX,CAAD,CADO,EAEb1E,MAAM,CAAC0E,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,EAAW,CAAX,CAAD,CAFO,EAGb3D,OAAO,CAACjB,CAAC,CAAC,CAAD,CAAF,CAHM,CALjB;AAUA,YAAMoF,EAAE,GAAGP,UAAU,CAACI,EAAD,CAArB;AAAA,YACEI,EAAE,GAAGR,UAAU,CAACM,EAAD,CADjB;AAEA,aAAO,CAACnF,CAAC,CAAC,CAAD,CAAF,EAAOqF,EAAP,EAAWrF,CAAC,CAAC,CAAD,CAAZ,EAAiBoF,EAAjB,CAAP;AACD;AACF,GA/BiB,CAAlB;;AAiCA,WAASP,UAAT,CAAoBS,KAApB,EAA2B;AACzB,QAAIC,CAAC,GAAG,CAAC,CAAT;AACAtE,IAAAA,OAAO,CAACyD,KAAR,CAAcrE,SAAS,CAACM,MAAxB,EAAgC6E,QAAhC,EAA0CnD,OAA1C,CAAkD,CAACrC,CAAD,EAAIsC,CAAJ,KAAU;AAC1D,UAAItC,CAAC,CAAC,CAAD,CAAD,KAASsF,KAAK,CAAC,CAAD,CAAd,IAAqBtF,CAAC,CAAC,CAAD,CAAD,KAASsF,KAAK,CAAC,CAAD,CAAvC,EAA4CC,CAAC,GAAGjD,CAAC,GAAGjC,SAAS,CAACM,MAAlB;AAC7C,KAFD;AAGA,QAAI4E,CAAC,GAAG,CAAR,EAAYA,CAAC,GAAGtE,OAAO,CAACN,MAAb,EAAsBM,OAAO,CAACoC,IAAR,CAAaiC,KAAb,CAAtB;AACX,WAAOC,CAAP;AACD;;AAED,SAAO;AAAEvE,IAAAA,QAAQ,EAAEgE,SAAZ;AAAuB/D,IAAAA;AAAvB,GAAP;AACD;;AAED,SAASiE,UAAT,CAAoBxD,CAApB,EAAuBC,CAAvB,EAA0B4C,CAA1B,EAA6B;AAC3B7C,EAAAA,CAAC,GAAGlC,SAAS,CAACkC,CAAD,CAAb;AACAC,EAAAA,CAAC,GAAGnC,SAAS,CAACmC,CAAD,CAAb;AACA4C,EAAAA,CAAC,GAAG/E,SAAS,CAAC+E,CAAD,CAAb;AACA,QAAMkB,CAAC,GAAG7G,IAAI,CAACS,GAAG,CAACF,KAAK,CAACwC,CAAD,EAAID,CAAJ,CAAN,EAAc6C,CAAd,CAAJ,CAAd;AACA,SAAOhF,SAAS,CAACN,SAAS,CAACK,YAAY,CAACoC,CAAD,EAAIC,CAAJ,CAAb,CAAT,CAA8B5B,GAA9B,CAAkCqE,CAAC,IAAIqB,CAAC,GAAGrB,CAA3C,CAAD,CAAhB;AACD;;AAED,SAAShD,QAAT,CAAkBJ,QAAlB,EAA4B;AAC1B,QAAMG,IAAI,GAAG,EAAb;AACAH,EAAAA,QAAQ,CAACqB,OAAT,CAAiBuC,IAAI,IAAI;AACvB,QAAI,CAACA,IAAL,EAAW;AACX,QAAI5E,CAAC,GAAG4E,IAAI,CAACA,IAAI,CAACjE,MAAL,GAAc,CAAf,CAAZ;;AACA,SAAK,IAAI+E,CAAT,IAAcd,IAAd,EAAoB;AAClB,UAAIc,CAAC,GAAG1F,CAAR,EAAWmB,IAAI,CAACkC,IAAL,CAAU,CAACrD,CAAD,EAAI0F,CAAJ,CAAV;AACX1F,MAAAA,CAAC,GAAG0F,CAAJ;AACD;AACF,GAPD;AAQA,SAAOvE,IAAP;AACD;;AAED,SAASK,YAAT,CAAsBjB,KAAtB,EAA6BF,SAA7B,EAAwC;AACtC,SAAO,UAASsF,SAAT,EAAoB;AACzB,UAAMC,QAAQ,GAAG,EAAjB;AAAA,UACEC,SAAS,GAAG,EADd;AAEAtF,IAAAA,KAAK,CAAC8B,OAAN,CAAc,CAACyD,IAAD,EAAOxD,CAAP,KAAa;AACzB,YAAMyD,CAAC,GAAGD,IAAI,CAAC7B,IAAL,CAAU,GAAV,CAAV;AACA2B,MAAAA,QAAQ,CAACG,CAAD,CAAR,GAAcJ,SAAS,CAACrD,CAAD,CAAvB;AACAuD,MAAAA,SAAS,CAACE,CAAD,CAAT,GAAe,IAAf;AACD,KAJD;AAMA1F,IAAAA,SAAS,CAACgC,OAAV,CAAkB2B,GAAG,IAAI;AACvB,UAAIL,CAAC,GAAG,CAAR;AAAA,UACEqC,MAAM,GAAG,CAAC,CADZ;;AAEA,WAAK,IAAIpC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAImC,CAAC,GAAG9H,MAAM,CAAC,CAAC+F,GAAG,CAACJ,CAAD,CAAJ,EAASI,GAAG,CAAC,CAACJ,CAAC,GAAG,CAAL,IAAU,CAAX,CAAZ,CAAD,CAAN,CAAmCK,IAAnC,CAAwC,GAAxC,CAAR;;AACA,YAAI2B,QAAQ,CAACG,CAAD,CAAR,GAAcpC,CAAlB,EAAqB;AACnBA,UAAAA,CAAC,GAAGiC,QAAQ,CAACG,CAAD,CAAZ;AACAC,UAAAA,MAAM,GAAGD,CAAT;AACD;AACF;;AACDF,MAAAA,SAAS,CAACG,MAAD,CAAT,GAAoB,KAApB;AACD,KAXD;AAaA,WAAOzF,KAAK,CAACR,GAAN,CAAU+F,IAAI,IAAID,SAAS,CAACC,IAAI,CAAC7B,IAAL,CAAU,GAAV,CAAD,CAA3B,CAAP;AACD,GAvBD;AAwBD;;AAED,SAAS3C,QAAT,CAAkBjB,SAAlB,EAA6BH,MAA7B,EAAqC;AACnC,QAAM+F,KAAK,GAAG,EAAd;AAAA,QACE5E,IAAI,GAAG,EADT;AAEAhB,EAAAA,SAAS,CAACN,GAAV,CAAciE,GAAG,IAAI;AACnB,QAAInE,MAAM,CAACmE,GAAG,CAACjE,GAAJ,CAAQuC,CAAC,IAAIpC,MAAM,CAACoC,CAAC,GAAGpC,MAAM,CAACS,MAAX,GAAoB,CAApB,GAAwB2B,CAAzB,CAAnB,CAAD,CAAN,GAA0D,CAA9D,EAAiE;;AACjE,SAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,UAAI4D,CAAC,GAAG,CAAClC,GAAG,CAAC1B,CAAD,CAAJ,EAAS0B,GAAG,CAAC,CAAC1B,CAAC,GAAG,CAAL,IAAU,CAAX,CAAZ,CAAR;AAAA,UACE6D,IAAI,GAAI,GAAED,CAAC,CAAC,CAAD,CAAI,IAAGA,CAAC,CAAC,CAAD,CAAI,EADzB;AAEA,UAAID,KAAK,CAACE,IAAD,CAAT,EAAiB,OAAOF,KAAK,CAACE,IAAD,CAAZ,CAAjB,KACKF,KAAK,CAACC,CAAC,CAACjC,IAAF,CAAO,GAAP,CAAD,CAAL,GAAqB,IAArB;AACN;AACF,GARD;AAUA,QAAMF,MAAM,GAAG,EAAf;AACA,MAAIqC,KAAJ;AACAlC,EAAAA,MAAM,CAACC,IAAP,CAAY8B,KAAZ,EAAmB5D,OAAnB,CAA2B6D,CAAC,IAAI;AAC9BA,IAAAA,CAAC,GAAGA,CAAC,CAAC7B,KAAF,CAAQ,GAAR,EAAatE,GAAb,CAAiBuE,MAAjB,CAAJ;AACAP,IAAAA,MAAM,CAACmC,CAAC,CAAC,CAAD,CAAF,CAAN,GAAeA,CAAC,CAAC,CAAD,CAAhB;AACAE,IAAAA,KAAK,GAAGF,CAAC,CAAC,CAAD,CAAT;AACD,GAJD;AAMA,MAAIE,KAAK,KAAKpE,SAAd,EAAyB,OAAOX,IAAP;AAEzB,MAAIU,IAAI,GAAGqE,KAAX;;AACA,KAAG;AACD/E,IAAAA,IAAI,CAACgC,IAAL,CAAUtB,IAAV;AACA,QAAImB,CAAC,GAAGa,MAAM,CAAChC,IAAD,CAAd;AACAgC,IAAAA,MAAM,CAAChC,IAAD,CAAN,GAAe,CAAC,CAAhB;AACAA,IAAAA,IAAI,GAAGmB,CAAP;AACD,GALD,QAKSnB,IAAI,GAAG,CAAC,CAAR,IAAaA,IAAI,KAAKqE,KAL/B;;AAOA,SAAO/E,IAAP;AACD","sourcesContent":["//\n// (c) 2019 Philippe Riviere\n//\n// https://github.com/Fil/\n//\n// This software is distributed under the terms of the MIT License\n\nimport { Delaunay } from \"d3-delaunay\";\nimport { geoRotation, geoStereographic } from \"d3-geo\";\nimport { extent } from \"d3-array\";\nimport {\n  asin,\n  atan,\n  atan2,\n  cos,\n  degrees,\n  halfPi,\n  max,\n  min,\n  pi,\n  radians,\n  sign,\n  sin,\n  sqrt,\n  tan\n} from \"./math.js\";\nimport {\n  cartesianNormalize as normalize,\n  cartesianCross as cross,\n  cartesianDot as dot,\n  cartesianAdd\n} from \"./cartesian.js\";\n\n// Converts 3D Cartesian to spherical coordinates (degrees).\nfunction spherical(cartesian) {\n  return [\n    atan2(cartesian[1], cartesian[0]) * degrees,\n    asin(max(-1, min(1, cartesian[2]))) * degrees\n  ];\n}\n\n// Converts spherical coordinates (degrees) to 3D Cartesian.\nfunction cartesian(coordinates) {\n  var lambda = coordinates[0] * radians,\n    phi = coordinates[1] * radians,\n    cosphi = cos(phi);\n  return [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];\n}\n\n// Spherical excess of a triangle (in spherical coordinates)\nexport function excess(triangle) {\n  triangle = triangle.map(p => cartesian(p));\n  return dot(triangle[0], cross(triangle[2], triangle[1]));\n}\n\nexport function geoDelaunay(points) {\n  const delaunay = geo_delaunay_from(points),\n    triangles = geo_triangles(delaunay),\n    edges = geo_edges(triangles, points),\n    neighbors = geo_neighbors(triangles, points.length),\n    find = geo_find(neighbors, points),\n    // Voronoi ; could take a center function as an argument\n    circumcenters = geo_circumcenters(triangles, points),\n    { polygons, centers } = geo_polygons(circumcenters, triangles, points),\n    mesh = geo_mesh(polygons),\n    hull = geo_hull(triangles, points),\n    // Urquhart ; returns a function that takes a distance array as argument.\n    urquhart = geo_urquhart(edges, triangles);\n  return {\n    delaunay,\n    edges,\n    triangles,\n    centers,\n    neighbors,\n    polygons,\n    mesh,\n    hull,\n    urquhart,\n    find\n  };\n}\n\nfunction geo_find(neighbors, points) {\n  function distance2(a,b) {\n    let x = a[0] - b[0],\n        y = a[1] - b[1],\n        z = a[2] - b[2];\n    return x * x + y * y + z * z;\n  }\n\n  return function find(x, y, next) {\n    if (next === undefined) next = 0;\n    let cell,\n      dist,\n      found = next;\n    const xyz = cartesian([x, y]);\n    do {\n      cell = next;\n      next = null;\n      dist = distance2(xyz, cartesian(points[cell]));\n      neighbors[cell].forEach(i => {\n        let ndist = distance2(xyz, cartesian(points[i]));\n        if (ndist < dist) {\n          dist = ndist;\n          next = i;\n          found = i;\n          return;\n        }\n      });\n    } while (next !== null);\n\n    return found;\n  };\n}\n\nfunction geo_delaunay_from(points) {\n  if (points.length < 2) return {};\n\n  // find a valid point to send to infinity\n  let pivot = 0;\n  while (isNaN(points[pivot][0]+points[pivot][1]) && pivot++ < points.length) {}\n\n  const r = geoRotation(points[pivot]),\n    projection = geoStereographic()\n      .translate([0, 0])\n      .scale(1)\n      .rotate(r.invert([180, 0]));\n  points = points.map(projection);\n\n  const zeros = [];\n  let max2 = 1;\n  for (let i = 0, n = points.length; i < n; i++) {\n    let m = points[i][0] ** 2 + points[i][1] ** 2;\n    if (!isFinite(m) || m > 1e32) zeros.push(i);\n    else if (m > max2) max2 = m;\n  }\n\n  const FAR = 1e6 * sqrt(max2);\n\n  zeros.forEach(i => (points[i] = [FAR, 0]));\n\n  // Add infinite horizon points\n  points.push([0,FAR]);\n  points.push([-FAR,0]);\n  points.push([0,-FAR]);\n\n  const delaunay = Delaunay.from(points);\n\n  delaunay.projection = projection;\n\n  // clean up the triangulation\n  const {triangles, halfedges, inedges} = delaunay;\n  const degenerate = [];\n  for (let i = 0, l = halfedges.length; i < l; i++) {\n    if (halfedges[i] < 0) {\n      const j = i % 3 == 2 ? i - 2 : i + 1;\n      const k = i % 3 == 0 ? i + 2 : i - 1;\n      const a = halfedges[j];\n      const b = halfedges[k];\n      halfedges[a] = b;\n      halfedges[b] = a;\n      halfedges[j] = halfedges[k] = -1;\n      triangles[i] = triangles[j] = triangles[k] = pivot;\n      inedges[triangles[a]] = a % 3 == 0 ? a + 2 : a - 1;\n      inedges[triangles[b]] = b % 3 == 0 ? b + 2 : b - 1;\n      degenerate.push(Math.min(i,j,k));\n      i += 2 - i % 3;\n    } else if (triangles[i] > points.length - 3 - 1) {\n      triangles[i] = pivot;\n    }\n  }\n  \n  // there should always be 4 degenerate triangles\n  // console.warn(degenerate);\n  return delaunay;\n}\n\nfunction geo_edges(triangles, points) {\n  const _index = {};\n  if (points.length === 2) return [[0, 1]];\n  triangles.forEach(tri => {\n    if (tri[0] === tri[1]) return;\n    if (excess(tri.map(i => points[i])) < 0) return;\n    for (let i = 0, j; i < 3; i++) {\n      j = (i + 1) % 3;\n      _index[extent([tri[i], tri[j]]).join(\"-\")] = true;\n    }\n  });\n  return Object.keys(_index).map(d => d.split(\"-\").map(Number));\n}\n\nfunction geo_triangles(delaunay) {\n  const {triangles} = delaunay;\n  if (!triangles) return [];\n\n  const geo_triangles = [];\n  for (let i = 0, n = triangles.length / 3; i < n; i++) {\n    const a = triangles[3 * i],\n      b = triangles[3 * i + 1],\n      c = triangles[3 * i + 2];\n    if (a !== b && b !== c) {\n      geo_triangles.push([a, c, b]);\n    }\n  }\n  return geo_triangles;\n}\n\nfunction geo_circumcenters(triangles, points) {\n  // if (!use_centroids) {\n  return triangles.map(tri => {\n    const c = tri.map(i => points[i]).map(cartesian),\n      V = cartesianAdd(\n        cartesianAdd(cross(c[1], c[0]), cross(c[2], c[1])),\n        cross(c[0], c[2])\n      );\n    return spherical(normalize(V));\n  });\n  /*} else {\n    return triangles.map(tri => {\n      return d3.geoCentroid({\n        type: \"MultiPoint\",\n        coordinates: tri.map(i => points[i])\n      });\n    });\n  }*/\n}\n\nfunction geo_neighbors(triangles, npoints) {\n  const neighbors = [];\n  triangles.forEach((tri, i) => {\n    for (let j = 0; j < 3; j++) {\n      const a = tri[j],\n        b = tri[(j + 1) % 3],\n        c = tri[(j + 2) % 3];\n      neighbors[a] = neighbors[a] || [];\n      neighbors[a].push(b);\n    }\n  });\n\n  // degenerate cases\n  if (triangles.length === 0) {\n    if (npoints === 2) (neighbors[0] = [1]), (neighbors[1] = [0]);\n    else if (npoints === 1) neighbors[0] = [];\n  }\n\n  return neighbors;\n}\n\nfunction geo_polygons(circumcenters, triangles, points) {\n  const polygons = [];\n\n  const centers = circumcenters.slice();\n\n  // supplementary centers for degenerate cases like n = 1,2,3\n  const supplements = [];\n\n  if (triangles.length === 0) {\n    if (points.length < 2) return { polygons, centers };\n    if (points.length === 2) {\n      // two hemispheres\n      const a = cartesian(points[0]),\n        b = cartesian(points[1]),\n        m = normalize(cartesianAdd(a, b)),\n        d = normalize(cross(a, b)),\n        c = cross(m, d);\n      const poly = [\n        m,\n        cross(m, c),\n        cross(cross(m, c), c),\n        cross(cross(cross(m, c), c), c)\n      ]\n        .map(spherical)\n        .map(supplement);\n      return (\n        polygons.push(poly),\n        polygons.push(poly.slice().reverse()),\n        { polygons, centers }\n      );\n    }\n  }\n\n  triangles.forEach((tri, t) => {\n    for (let j = 0; j < 3; j++) {\n      const a = tri[j],\n        b = tri[(j + 1) % 3],\n        c = tri[(j + 2) % 3];\n      polygons[a] = polygons[a] || [];\n      polygons[a].push([b, c, t, [a, b, c]]);\n    }\n  });\n\n  // reorder each polygon\n  const reordered = polygons.map(poly => {\n    const p = [poly[0][2]]; // t\n    let k = poly[0][1]; // k = c\n    for (let i = 1; i < poly.length; i++) {\n      // look for b = k\n      for (let j = 0; j < poly.length; j++) {\n        if (poly[j][0] == k) {\n          k = poly[j][1];\n          p.push(poly[j][2]);\n          break;\n        }\n      }\n    }\n\n    if (p.length > 2) {\n      return p;\n    } else if (p.length == 2) {\n      const R0 = o_midpoint(\n          points[poly[0][3][0]],\n          points[poly[0][3][1]],\n          centers[p[0]]\n        ),\n        R1 = o_midpoint(\n          points[poly[0][3][2]],\n          points[poly[0][3][0]],\n          centers[p[0]]\n        );\n      const i0 = supplement(R0),\n        i1 = supplement(R1);\n      return [p[0], i1, p[1], i0];\n    }\n  });\n\n  function supplement(point) {\n    let f = -1;\n    centers.slice(triangles.length, Infinity).forEach((p, i) => {\n      if (p[0] === point[0] && p[1] === point[1]) f = i + triangles.length;\n    });\n    if (f < 0) (f = centers.length), centers.push(point);\n    return f;\n  }\n\n  return { polygons: reordered, centers };\n}\n\nfunction o_midpoint(a, b, c) {\n  a = cartesian(a);\n  b = cartesian(b);\n  c = cartesian(c);\n  const s = sign(dot(cross(b, a), c));\n  return spherical(normalize(cartesianAdd(a, b)).map(d => s * d));\n}\n\nfunction geo_mesh(polygons) {\n  const mesh = [];\n  polygons.forEach(poly => {\n    if (!poly) return;\n    let p = poly[poly.length - 1];\n    for (let q of poly) {\n      if (q > p) mesh.push([p, q]);\n      p = q;\n    }\n  });\n  return mesh;\n}\n\nfunction geo_urquhart(edges, triangles) {\n  return function(distances) {\n    const _lengths = {},\n      _urquhart = {};\n    edges.forEach((edge, i) => {\n      const u = edge.join(\"-\");\n      _lengths[u] = distances[i];\n      _urquhart[u] = true;\n    });\n\n    triangles.forEach(tri => {\n      let l = 0,\n        remove = -1;\n      for (var j = 0; j < 3; j++) {\n        let u = extent([tri[j], tri[(j + 1) % 3]]).join(\"-\");\n        if (_lengths[u] > l) {\n          l = _lengths[u];\n          remove = u;\n        }\n      }\n      _urquhart[remove] = false;\n    });\n\n    return edges.map(edge => _urquhart[edge.join(\"-\")]);\n  };\n}\n\nfunction geo_hull(triangles, points) {\n  const _hull = {},\n    hull = [];\n  triangles.map(tri => {\n    if (excess(tri.map(i => points[i > points.length ? 0 : i])) < 0) return;\n    for (let i = 0; i < 3; i++) {\n      let e = [tri[i], tri[(i + 1) % 3]],\n        code = `${e[1]}-${e[0]}`;\n      if (_hull[code]) delete _hull[code];\n      else _hull[e.join(\"-\")] = true;\n    }\n  });\n\n  const _index = {};\n  let start;\n  Object.keys(_hull).forEach(e => {\n    e = e.split(\"-\").map(Number);\n    _index[e[0]] = e[1];\n    start = e[0];\n  });\n\n  if (start === undefined) return hull;\n\n  let next = start;\n  do {\n    hull.push(next);\n    let n = _index[next];\n    _index[next] = -1;\n    next = n;\n  } while (next > -1 && next !== start);\n\n  return hull;\n}\n"]},"metadata":{},"sourceType":"module"}