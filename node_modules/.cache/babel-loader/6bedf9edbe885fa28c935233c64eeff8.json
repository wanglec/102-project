{"ast":null,"code":"import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, Vector2, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _box$1 = new THREE$2.Box3();\n\nconst _vector = new THREE$2.Vector3();\n\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  setPositions(array) {\n    let lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n\n  setColors(array) {\n    let colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n\n  romLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n\n      _box$1.setFromBufferAttribute(end);\n\n      this.boundingBox.union(_box$1);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n\n        _vector.fromBufferAttribute(end, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  toJSON() {// todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n}\n\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    this.dashed = false;\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nLineMaterial.prototype.isLineMaterial = true;\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4\n};\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _start = new THREE.Vector3();\n\nconst _end = new THREE.Vector3();\n\nconst _start4 = new THREE.Vector4();\n\nconst _end4 = new THREE.Vector4();\n\nconst _ssOrigin = new THREE.Vector4();\n\nconst _ssOrigin3 = new THREE.Vector3();\n\nconst _mvMatrix = new THREE.Matrix4();\n\nconst _line = new THREE.Line3();\n\nconst _closestPoint = new THREE.Vector3();\n\nconst _box = new THREE.Box3();\n\nconst _sphere = new THREE.Sphere();\n\nconst _clipToWorldVector = new THREE.Vector4();\n\nclass LineSegments2 extends THREE.Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n    _ssOrigin.applyMatrix4(projectionMatrix);\n\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n\n    _ssOrigin3.copy(_ssOrigin);\n\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n\n      _end4.fromBufferAttribute(instanceEnd, i);\n\n      _start.w = 1;\n      _end.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n\n        _end4.lerp(_start4, t);\n      } // clip space\n\n\n      _start4.applyMatrix4(projectionMatrix);\n\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n      _start4.multiplyScalar(1 / _start4.w);\n\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n\n      _line.start.z = 0;\n\n      _line.end.copy(_end4);\n\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n\n        _line.end.fromBufferAttribute(instanceEnd, i);\n\n        _line.start.applyMatrix4(matrixWorld);\n\n        _line.end.applyMatrix4(matrixWorld);\n\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n\n}\n\nLineSegments2.prototype.LineSegments2 = true;\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    super.setPositions(points);\n    return this;\n  }\n\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    super.setColors(colors);\n    return this;\n  }\n\n  fromLine(line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  copy() {\n    // todo\n    return this;\n  }\n\n}\n\nLineGeometry.prototype.isLineGeometry = true;\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n\n}\n\nLine2.prototype.isLine2 = true;\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };","map":{"version":3,"sources":["/Users/lechuanwang/Documents/2021 spring/dsc106/project/dsc102/102-project/node_modules/three-fatline/dist/three-fatline.module.js"],"names":["Box3","BufferGeometry","Float32BufferAttribute","InstancedBufferGeometry","InstancedInterleavedBuffer","InterleavedBufferAttribute","Sphere","Vector3","WireframeGeometry","Vector2","ShaderLib","ShaderMaterial","UniformsLib","UniformsUtils","Line3","MathUtils","Matrix4","Mesh","Vector4","THREE$2","window","THREE","setAttributeFn$1","setAttribute","_box$1","_vector","LineSegmentsGeometry","constructor","type","positions","uvs","index","setIndex","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","romLineSegments","isGeometry","console","error","isBufferGeometry","setFromBufferAttribute","union","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","toJSON","applyMatrix","warn","prototype","isLineSegmentsGeometry","THREE$1","line","linewidth","value","resolution","dashScale","dashSize","dashOffset","gapSize","opacity","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","clone","clipping","dashed","Object","defineProperties","color","enumerable","get","diffuse","set","copy","alphaToCoverage","Boolean","defines","ALPHA_TO_COVERAGE","extensions","derivatives","setValues","isLineMaterial","setAttributeFn","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","LineSegments2","material","random","computeLineDistances","lineDistances","j","l","distanceTo","instanceDistanceBuffer","raycast","raycaster","intersects","camera","threshold","params","Line2","ray","projectionMatrix","matrixWorld","lineWidth","near","ssMaxWidth","width","height","distanceToSphere","distanceToPoint","origin","multiplyScalar","w","projectionMatrixInverse","sphereMargin","abs","intersectsSphere","distanceToBox","boxMargin","x","y","z","min","intersectsBox","at","matrixWorldInverse","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","object","face","faceIndex","uv","uv2","LineGeometry","length","points","fromLine","isLineGeometry","isLine2"],"mappings":"AAAA,SAASA,IAAT,EAAeC,cAAf,EAA+BC,sBAA/B,EAAuDC,uBAAvD,EAAgFC,0BAAhF,EAA4GC,0BAA5G,EAAwIC,MAAxI,EAAgJC,OAAhJ,EAAyJC,iBAAzJ,EAA4KC,OAA5K,EAAqLC,SAArL,EAAgMC,cAAhM,EAAgNC,WAAhN,EAA6NC,aAA7N,EAA4OC,KAA5O,EAAmPC,SAAnP,EAA8PC,OAA9P,EAAuQC,IAAvQ,EAA6QC,OAA7Q,QAA4R,OAA5R;AAEA,MAAMC,OAAO,GAAGC,MAAM,CAACC,KAAP,GAAeD,MAAM,CAACC,KAAtB,CAA4B;AAA5B,EACd;AACArB,EAAAA,IADA;AAEAC,EAAAA,cAFA;AAGAC,EAAAA,sBAHA;AAIAC,EAAAA,uBAJA;AAKAC,EAAAA,0BALA;AAMAC,EAAAA,0BANA;AAOAC,EAAAA,MAPA;AAQAC,EAAAA,OARA;AASAC,EAAAA;AATA,CADF,C,CAWG;;AAEH,IAAIc,gBAAgB,GAAG,IAAIH,OAAO,CAAClB,cAAZ,GAA6BsB,YAA7B,GAA4C,cAA5C,GAA6D,cAApF;;AAEA,MAAMC,MAAM,GAAG,IAAIL,OAAO,CAACnB,IAAZ,EAAf;;AAEA,MAAMyB,OAAO,GAAG,IAAIN,OAAO,CAACZ,OAAZ,EAAhB;;AAEA,MAAMmB,oBAAN,SAAmCP,OAAO,CAAChB,uBAA3C,CAAmE;AACjEwB,EAAAA,WAAW,GAAG;AACZ;AACA,SAAKC,IAAL,GAAY,sBAAZ;AACA,UAAMC,SAAS,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAAC,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAApC,EAAuC,CAAC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,EAAuD,CAAvD,EAA0D,CAAC,CAA3D,EAA8D,CAAC,CAA/D,EAAkE,CAAlE,EAAqE,CAArE,EAAwE,CAAC,CAAzE,EAA4E,CAA5E,CAAlB;AACA,UAAMC,GAAG,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAC,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAAC,CAA5B,EAA+B,CAAC,CAAhC,EAAmC,CAAnC,EAAsC,CAAC,CAAvC,EAA0C,CAAC,CAA3C,EAA8C,CAAC,CAA/C,EAAkD,CAAlD,EAAqD,CAAC,CAAtD,CAAZ;AACA,UAAMC,KAAK,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,CAAd;AACA,SAAKC,QAAL,CAAcD,KAAd;AACA,SAAKT,gBAAL,EAAuB,UAAvB,EAAmC,IAAIH,OAAO,CAACjB,sBAAZ,CAAmC2B,SAAnC,EAA8C,CAA9C,CAAnC;AACA,SAAKP,gBAAL,EAAuB,IAAvB,EAA6B,IAAIH,OAAO,CAACjB,sBAAZ,CAAmC4B,GAAnC,EAAwC,CAAxC,CAA7B;AACD;;AAEDG,EAAAA,YAAY,CAACC,MAAD,EAAS;AACnB,UAAMC,KAAK,GAAG,KAAKC,UAAL,CAAgBC,aAA9B;AACA,UAAMC,GAAG,GAAG,KAAKF,UAAL,CAAgBG,WAA5B;;AAEA,QAAIJ,KAAK,KAAKK,SAAd,EAAyB;AACvBL,MAAAA,KAAK,CAACF,YAAN,CAAmBC,MAAnB;AACAI,MAAAA,GAAG,CAACL,YAAJ,CAAiBC,MAAjB;AACAC,MAAAA,KAAK,CAACM,WAAN,GAAoB,IAApB;AACD;;AAED,QAAI,KAAKC,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAKC,kBAAL;AACD;;AAED,QAAI,KAAKC,cAAL,KAAwB,IAA5B,EAAkC;AAChC,WAAKC,qBAAL;AACD;;AAED,WAAO,IAAP;AACD;;AAEDC,EAAAA,YAAY,CAACC,KAAD,EAAQ;AAClB,QAAIC,YAAJ;;AAEA,QAAID,KAAK,YAAYE,YAArB,EAAmC;AACjCD,MAAAA,YAAY,GAAGD,KAAf;AACD,KAFD,MAEO,IAAIG,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAAJ,EAA0B;AAC/BC,MAAAA,YAAY,GAAG,IAAIC,YAAJ,CAAiBF,KAAjB,CAAf;AACD;;AAED,UAAMK,cAAc,GAAG,IAAIjC,OAAO,CAACf,0BAAZ,CAAuC4C,YAAvC,EAAqD,CAArD,EAAwD,CAAxD,CAAvB,CATkB,CASiE;;AAEnF,SAAK1B,gBAAL,EAAuB,eAAvB,EAAwC,IAAIH,OAAO,CAACd,0BAAZ,CAAuC+C,cAAvC,EAAuD,CAAvD,EAA0D,CAA1D,CAAxC,EAXkB,CAWqF;;AAEvG,SAAK9B,gBAAL,EAAuB,aAAvB,EAAsC,IAAIH,OAAO,CAACd,0BAAZ,CAAuC+C,cAAvC,EAAuD,CAAvD,EAA0D,CAA1D,CAAtC,EAbkB,CAamF;AACrG;;AAEA,SAAKT,kBAAL;AACA,SAAKE,qBAAL;AACA,WAAO,IAAP;AACD;;AAEDQ,EAAAA,SAAS,CAACN,KAAD,EAAQ;AACf,QAAIO,MAAJ;;AAEA,QAAIP,KAAK,YAAYE,YAArB,EAAmC;AACjCK,MAAAA,MAAM,GAAGP,KAAT;AACD,KAFD,MAEO,IAAIG,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAAJ,EAA0B;AAC/BO,MAAAA,MAAM,GAAG,IAAIL,YAAJ,CAAiBF,KAAjB,CAAT;AACD;;AAED,UAAMQ,mBAAmB,GAAG,IAAIpC,OAAO,CAACf,0BAAZ,CAAuCkD,MAAvC,EAA+C,CAA/C,EAAkD,CAAlD,CAA5B,CATe,CASmE;;AAElF,SAAKhC,gBAAL,EAAuB,oBAAvB,EAA6C,IAAIH,OAAO,CAACd,0BAAZ,CAAuCkD,mBAAvC,EAA4D,CAA5D,EAA+D,CAA/D,CAA7C,EAXe,CAWkG;;AAEjH,SAAKjC,gBAAL,EAAuB,kBAAvB,EAA2C,IAAIH,OAAO,CAACd,0BAAZ,CAAuCkD,mBAAvC,EAA4D,CAA5D,EAA+D,CAA/D,CAA3C,EAbe,CAagG;;AAE/G,WAAO,IAAP;AACD;;AAEDC,EAAAA,qBAAqB,CAACC,QAAD,EAAW;AAC9B,SAAKX,YAAL,CAAkBW,QAAQ,CAACrB,UAAT,CAAoBsB,QAApB,CAA6BX,KAA/C;AACA,WAAO,IAAP;AACD;;AAEDY,EAAAA,iBAAiB,CAACF,QAAD,EAAW;AAC1B,SAAKX,YAAL,CAAkBW,QAAQ,CAACrB,UAAT,CAAoBsB,QAApB,CAA6BX,KAA/C;AACA,WAAO,IAAP;AACD;;AAEDa,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACb,SAAKL,qBAAL,CAA2B,IAAIrC,OAAO,CAACX,iBAAZ,CAA8BqD,IAAI,CAACJ,QAAnC,CAA3B,EADa,CAC6D;;AAE1E,WAAO,IAAP;AACD;;AAEDK,EAAAA,eAAe,CAACd,YAAD,EAAe;AAC5B,UAAMS,QAAQ,GAAGT,YAAY,CAACS,QAA9B;;AAEA,QAAIA,QAAQ,CAACM,UAAb,EAAyB;AACvBC,MAAAA,OAAO,CAACC,KAAR,CAAc,qFAAd;AACA;AACD,KAHD,MAGO,IAAIR,QAAQ,CAACS,gBAAb,EAA+B;AACpC,WAAKpB,YAAL,CAAkBW,QAAQ,CAACrB,UAAT,CAAoBsB,QAApB,CAA6BX,KAA/C,EADoC,CACmB;AACxD,KAR2B,CAQ1B;;;AAGF,WAAO,IAAP;AACD;;AAEDJ,EAAAA,kBAAkB,GAAG;AACnB,QAAI,KAAKD,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAKA,WAAL,GAAmB,IAAIvB,OAAO,CAACnB,IAAZ,EAAnB;AACD;;AAED,UAAMmC,KAAK,GAAG,KAAKC,UAAL,CAAgBC,aAA9B;AACA,UAAMC,GAAG,GAAG,KAAKF,UAAL,CAAgBG,WAA5B;;AAEA,QAAIJ,KAAK,KAAKK,SAAV,IAAuBF,GAAG,KAAKE,SAAnC,EAA8C;AAC5C,WAAKE,WAAL,CAAiByB,sBAAjB,CAAwChC,KAAxC;;AAEAX,MAAAA,MAAM,CAAC2C,sBAAP,CAA8B7B,GAA9B;;AAEA,WAAKI,WAAL,CAAiB0B,KAAjB,CAAuB5C,MAAvB;AACD;AACF;;AAEDqB,EAAAA,qBAAqB,GAAG;AACtB,QAAI,KAAKD,cAAL,KAAwB,IAA5B,EAAkC;AAChC,WAAKA,cAAL,GAAsB,IAAIzB,OAAO,CAACb,MAAZ,EAAtB;AACD;;AAED,QAAI,KAAKoC,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAKC,kBAAL;AACD;;AAED,UAAMR,KAAK,GAAG,KAAKC,UAAL,CAAgBC,aAA9B;AACA,UAAMC,GAAG,GAAG,KAAKF,UAAL,CAAgBG,WAA5B;;AAEA,QAAIJ,KAAK,KAAKK,SAAV,IAAuBF,GAAG,KAAKE,SAAnC,EAA8C;AAC5C,YAAM6B,MAAM,GAAG,KAAKzB,cAAL,CAAoByB,MAAnC;AACA,WAAK3B,WAAL,CAAiB4B,SAAjB,CAA2BD,MAA3B;AACA,UAAIE,WAAW,GAAG,CAAlB;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGtC,KAAK,CAACuC,KAA3B,EAAkCF,CAAC,GAAGC,EAAtC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C/C,QAAAA,OAAO,CAACkD,mBAAR,CAA4BxC,KAA5B,EAAmCqC,CAAnC;;AAEAD,QAAAA,WAAW,GAAGK,IAAI,CAACC,GAAL,CAASN,WAAT,EAAsBF,MAAM,CAACS,iBAAP,CAAyBrD,OAAzB,CAAtB,CAAd;;AAEAA,QAAAA,OAAO,CAACkD,mBAAR,CAA4BrC,GAA5B,EAAiCkC,CAAjC;;AAEAD,QAAAA,WAAW,GAAGK,IAAI,CAACC,GAAL,CAASN,WAAT,EAAsBF,MAAM,CAACS,iBAAP,CAAyBrD,OAAzB,CAAtB,CAAd;AACD;;AAED,WAAKmB,cAAL,CAAoBmC,MAApB,GAA6BH,IAAI,CAACI,IAAL,CAAUT,WAAV,CAA7B;;AAEA,UAAIU,KAAK,CAAC,KAAKrC,cAAL,CAAoBmC,MAArB,CAAT,EAAuC;AACrCf,QAAAA,OAAO,CAACC,KAAR,CAAc,uIAAd,EAAuJ,IAAvJ;AACD;AACF;AACF;;AAEDiB,EAAAA,MAAM,GAAG,CAAC;AACT;;AAEDC,EAAAA,WAAW,CAACjD,MAAD,EAAS;AAClB8B,IAAAA,OAAO,CAACoB,IAAR,CAAa,+EAAb;AACA,WAAO,KAAKnD,YAAL,CAAkBC,MAAlB,CAAP;AACD;;AAhKgE;;AAoKnER,oBAAoB,CAAC2D,SAArB,CAA+BC,sBAA/B,GAAwD,IAAxD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,OAAO,GAAGnE,MAAM,CAACC,KAAP,GAAeD,MAAM,CAACC,KAAtB,CAA4B;AAA5B,EACd;AACAX,EAAAA,SADA;AAEAC,EAAAA,cAFA;AAGAC,EAAAA,WAHA;AAIAC,EAAAA,aAJA;AAKAJ,EAAAA;AALA,CADF;AAQA8E,OAAO,CAAC3E,WAAR,CAAoB4E,IAApB,GAA2B;AACzBC,EAAAA,SAAS,EAAE;AACTC,IAAAA,KAAK,EAAE;AADE,GADc;AAIzBC,EAAAA,UAAU,EAAE;AACVD,IAAAA,KAAK,EAAE,IAAIjF,OAAJ,CAAY,CAAZ,EAAe,CAAf;AADG,GAJa;AAOzBmF,EAAAA,SAAS,EAAE;AACTF,IAAAA,KAAK,EAAE;AADE,GAPc;AAUzBG,EAAAA,QAAQ,EAAE;AACRH,IAAAA,KAAK,EAAE;AADC,GAVe;AAazBI,EAAAA,UAAU,EAAE;AACVJ,IAAAA,KAAK,EAAE;AADG,GAba;AAgBzBK,EAAAA,OAAO,EAAE;AACPL,IAAAA,KAAK,EAAE;AADA,GAhBgB;AAmBzB;AACAM,EAAAA,OAAO,EAAE;AACPN,IAAAA,KAAK,EAAE;AADA;AApBgB,CAA3B;AAwBAH,OAAO,CAAC7E,SAAR,CAAkB,MAAlB,IAA4B;AAC1BuF,EAAAA,QAAQ,EAAEV,OAAO,CAAC1E,aAAR,CAAsBqF,KAAtB,CAA4B,CAACX,OAAO,CAAC3E,WAAR,CAAoBuF,MAArB,EAA6BZ,OAAO,CAAC3E,WAAR,CAAoBwF,GAAjD,EAAsDb,OAAO,CAAC3E,WAAR,CAAoB4E,IAA1E,CAA5B,CADgB;AAE1Ba,EAAAA,YAAY,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAlJ4B;AAmJ1BC,EAAAA,cAAc,EAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5M4B,CAA5B;;AA+MA,MAAMC,YAAN,SAA2BhB,OAAO,CAAC5E,cAAnC,CAAkD;AAChDgB,EAAAA,WAAW,CAAC6E,UAAD,EAAa;AACtB,UAAM;AACJ5E,MAAAA,IAAI,EAAE,cADF;AAEJqE,MAAAA,QAAQ,EAAEV,OAAO,CAAC1E,aAAR,CAAsB4F,KAAtB,CAA4BlB,OAAO,CAAC7E,SAAR,CAAkB,MAAlB,EAA0BuF,QAAtD,CAFN;AAGJI,MAAAA,YAAY,EAAEd,OAAO,CAAC7E,SAAR,CAAkB,MAAlB,EAA0B2F,YAHpC;AAIJC,MAAAA,cAAc,EAAEf,OAAO,CAAC7E,SAAR,CAAkB,MAAlB,EAA0B4F,cAJtC;AAKJI,MAAAA,QAAQ,EAAE,IALN,CAKW;;AALX,KAAN;AAQA,SAAKC,MAAL,GAAc,KAAd;AACAC,IAAAA,MAAM,CAA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","sourcesContent":["import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, Vector2, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\n\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _box$1 = new THREE$2.Box3();\n\nconst _vector = new THREE$2.Vector3();\n\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  setPositions(array) {\n    let lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n\n  setColors(array) {\n    let colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n\n  romLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n\n      _box$1.setFromBufferAttribute(end);\n\n      this.boundingBox.union(_box$1);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n\n        _vector.fromBufferAttribute(end, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  toJSON() {// todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n}\n\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    this.dashed = false;\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nLineMaterial.prototype.isLineMaterial = true;\n\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4\n};\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _start = new THREE.Vector3();\n\nconst _end = new THREE.Vector3();\n\nconst _start4 = new THREE.Vector4();\n\nconst _end4 = new THREE.Vector4();\n\nconst _ssOrigin = new THREE.Vector4();\n\nconst _ssOrigin3 = new THREE.Vector3();\n\nconst _mvMatrix = new THREE.Matrix4();\n\nconst _line = new THREE.Line3();\n\nconst _closestPoint = new THREE.Vector3();\n\nconst _box = new THREE.Box3();\n\nconst _sphere = new THREE.Sphere();\n\nconst _clipToWorldVector = new THREE.Vector4();\n\nclass LineSegments2 extends THREE.Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n    _ssOrigin.applyMatrix4(projectionMatrix);\n\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n\n    _ssOrigin3.copy(_ssOrigin);\n\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n\n      _end4.fromBufferAttribute(instanceEnd, i);\n\n      _start.w = 1;\n      _end.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n\n        _end4.lerp(_start4, t);\n      } // clip space\n\n\n      _start4.applyMatrix4(projectionMatrix);\n\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n      _start4.multiplyScalar(1 / _start4.w);\n\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n\n      _line.start.z = 0;\n\n      _line.end.copy(_end4);\n\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n\n        _line.end.fromBufferAttribute(instanceEnd, i);\n\n        _line.start.applyMatrix4(matrixWorld);\n\n        _line.end.applyMatrix4(matrixWorld);\n\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n\n}\n\nLineSegments2.prototype.LineSegments2 = true;\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    super.setPositions(points);\n    return this;\n  }\n\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    super.setColors(colors);\n    return this;\n  }\n\n  fromLine(line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  copy() {\n    // todo\n    return this;\n  }\n\n}\n\nLineGeometry.prototype.isLineGeometry = true;\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n\n}\n\nLine2.prototype.isLine2 = true;\n\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };\n"]},"metadata":{},"sourceType":"module"}